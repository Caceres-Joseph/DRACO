get_global 0 //APUNTADOR QUE QUEDERÁ GUARDADO EN TODAS LAS DECLARACIONES GLOBALES.
//RESERVO ESPACIO PARA LAS VARIABLES GLOBALES 
get_global 0 
1//Numero de declaraciones globales
add //Aumento el puntero en el heap
set_global 0 //Actualizo la posición en el heap.
1//Posición donde se encuentra la variable del arreglo
get_global 0 //Posición inicial del arreglo en el heap
set_global $calc //Se coloca el valor del puntero del heap en el heap
 
//....RESERVAR ARREGLO....

//----DECLARACION DE LA VARAIBLE QUE LLEVARÁ EL ITERADOR: i
get_local 0   //posicion actual en el puntero de la pila
2  //posición de la variable en la pila
add   //colocar la posición de la variable en la pilita
0 //valor inicial del iterador
set_local $calc   //asignación del valor en la pila
get_local 0   //posicion actual en el puntero de la pila
3  //posición de la variable en la pila
add   //colocar la posición de la variable en la pilita
//MULTIPLICACIÓN DE LAS DIMENSIONES PARA CALCULAR SU TAMAÑO.
4
set_local $calc   //asignación del valor en la pila
//--Guardar el valor de las dimensiones al inicio del arreglo.
get_global 0
4
set_global $calc
get_global 0
1 
add 
set_global 0
//-------AUMENTO DEL PUNTERO EL TAMAÑO DEL ARREGLO-------
get_global 0  //Puntero actual del heap
get_global 0
get_local 0
3
add
get_local $calc

add
set_global 0 //SE AUMENTA EL PUNTERO EL TAMAÑO DEL ARREGLO
$l1:     //Inicio del ciclo. 
//----CONDICIÓN DEL CICLO i < base: i
get_local 0
2
add
get_local $calc

get_local 0
3
add
get_local $calc

Lt
Eqz   // Se valida que la condición haya sido verdadera.
Br_if $l2   //Si es verdadera, hace un goto a la etiqueta verdadera.
Br $l3  //Si la condición es falsa, hace un goto a la etiqueta falsa.
$l2:  //Inicio de la lista de instrucciones. 
get_global 0
tee_global $calc
//----heap[i] el valor 
//DECLARACION EN STRUCT***************
-1//Valor inicial de la variable del struct
tee_global $calc  //asignación del valor en el heap
1
add
//DECLARACION EN STRUCT***************
0//Valor inicial de la variable del struct
tee_global $calc  //asignación del valor en el heap
1
add
//DECLARACION EN STRUCT***************
0//Valor inicial de la variable del struct
tee_global $calc  //asignación del valor en el heap
1
add
//DECLARACION EN STRUCT***************
92//Valor inicial de la variable del struct
tee_global $calc  //asignación del valor en el heap
1
add
//DECLARACION DE ARREGLO EN STRUCT|||||||||||||||||||
get_global 0 //Posición inicial del arreglo en el heap
tee_global $calc //Se coloca el valor del puntero del heap en el heap
 
//....RESERVAR ARREGLO....

//----DECLARACION DE LA VARAIBLE QUE LLEVARÁ EL ITERADOR: i
get_local 0   //posicion actual en el puntero de la pila
2  //posición de la variable en la pila
add   //colocar la posición de la variable en la pilita
0 //valor inicial del iterador
set_local $calc   //asignación del valor en la pila
get_local 0   //posicion actual en el puntero de la pila
3  //posición de la variable en la pila
add   //colocar la posición de la variable en la pilita
//MULTIPLICACIÓN DE LAS DIMENSIONES PARA CALCULAR SU TAMAÑO.
13
set_local $calc   //asignación del valor en la pila
//--Guardar el valor de las dimensiones al inicio del arreglo.
get_global 0
13
set_global $calc
get_global 0
1 
add 
set_global 0
$l5:     //Inicio del ciclo. 
//----CONDICIÓN DEL CICLO i < base: i
get_local 0
2
add
get_local $calc

get_local 0
3
add
get_local $calc

Lt
Eqz   // Se valida que la condición haya sido verdadera.
Br_if $l6   //Si es verdadera, hace un goto a la etiqueta verdadera.
Br $l7  //Si la condición es falsa, hace un goto a la etiqueta falsa.
$l6:  //Inicio de la lista de instrucciones. 
//----heap[i] el valor 
get_global 0  //Puntero actual del heap
0  //Valor inicial en la posición h[i]
set_global $calc  //Guardar valor inicial
//---H = H+1
get_global 0 //valor actual del puntero del heap
1 //Aumenta el puntero un tamaño en uno.
add //Aumento del puntero
set_global 0 //se actualiza el valor del puntero del heap.
//----ITERADOR = ITERADOR + 1
get_local 0
2
add
get_local 0
2
add
get_local $calc

1
Add
set_local $calc
Br $l5  //Al finalizar el ciclo, se hace un goto a la etiqueta de inicio del ciclo.
$l7:  // Inicio de la etiqueta falsa o de salida del ciclo. 
1
add


//.....FIN ARREGLO.....
1 //Se suma una posicion en el arreglo
add //Se le suma a la posicion del arreglo el valor del iterador.
//----ITERADOR = ITERADOR + 1
get_local 0
2
add
get_local 0
2
add
get_local $calc

1
Add
set_local $calc
Br $l1  //Al finalizar el ciclo, se hace un goto a la etiqueta de inicio del ciclo.
$l3:  // Inicio de la etiqueta falsa o de salida del ciclo. 


//.....FIN ARREGLO.....
br_if $l4
$l4:
br_if $l8
$l8:
Function $principal
get_local 0 //Apuntador de la pila
0//Posición donde se encuentra la variable del arreglo
add //Posición donde se guardará en la pila
 get_global 0 //Posición inicial del arreglo en el heap
set_local $calc //Se coloca el valor del puntero del heap en el stack
 
//....RESERVAR ARREGLO....

//----DECLARACION DE LA VARAIBLE QUE LLEVARÁ EL ITERADOR: i
get_local 0   //posicion actual en el puntero de la pila
1  //posición de la variable en la pila
add   //colocar la posición de la variable en la pilita
0 //valor inicial del iterador
set_local $calc   //asignación del valor en la pila
get_local 0   //posicion actual en el puntero de la pila
2  //posición de la variable en la pila
add   //colocar la posición de la variable en la pilita
//MULTIPLICACIÓN DE LAS DIMENSIONES PARA CALCULAR SU TAMAÑO.
13
set_local $calc   //asignación del valor en la pila
//--Guardar el valor de las dimensiones al inicio del arreglo.
get_global 0
13
set_global $calc
get_global 0
1 
add 
set_global 0
$l9:     //Inicio del ciclo. 
//----CONDICIÓN DEL CICLO i < base: i
get_local 0
1
add
get_local $calc

get_local 0
2
add
get_local $calc

Lt
Eqz   // Se valida que la condición haya sido verdadera.
Br_if $l10   //Si es verdadera, hace un goto a la etiqueta verdadera.
Br $l11  //Si la condición es falsa, hace un goto a la etiqueta falsa.
$l10:  //Inicio de la lista de instrucciones. 
//----heap[i] el valor 
get_global 0  //Puntero actual del heap
0  //Valor inicial en la posición h[i]
set_global $calc  //Guardar valor inicial
//---H = H+1
get_global 0 //valor actual del puntero del heap
1 //Aumenta el puntero un tamaño en uno.
add //Aumento del puntero
set_global 0 //se actualiza el valor del puntero del heap.
//----ITERADOR = ITERADOR + 1
get_local 0
1
add
get_local 0
1
add
get_local $calc

1
Add
set_local $calc
Br $l9  //Al finalizar el ciclo, se hace un goto a la etiqueta de inicio del ciclo.
$l11:  // Inicio de la etiqueta falsa o de salida del ciclo. 


//.....FIN ARREGLO.....
//INICIALIZAR ARREGLO CON VALORES DE LA FORMA DE {}{}{}{}------------------.....------
get_local 0 //Posicion actual puntero pila
0
add
get_local $calc //Posicion donde inicia el arreglo.
1//Numero de dimensiones
add //Me coloco en la primera posicion que tiene valores del arreglo.
0//Posición donde irá el valor en el arreglo.
add //Obtengo la posición donde irá el valor
2
//VALOR.
set_global $calc
//INICIALIZAR ARREGLO CON VALORES DE LA FORMA DE {}{}{}{}------------------.....------
get_local 0 //Posicion actual puntero pila
0
add
get_local $calc //Posicion donde inicia el arreglo.
1//Numero de dimensiones
add //Me coloco en la primera posicion que tiene valores del arreglo.
1//Posición donde irá el valor en el arreglo.
add //Obtengo la posición donde irá el valor
0
//VALOR.
set_global $calc
//INICIALIZAR ARREGLO CON VALORES DE LA FORMA DE {}{}{}{}------------------.....------
get_local 0 //Posicion actual puntero pila
0
add
get_local $calc //Posicion donde inicia el arreglo.
1//Numero de dimensiones
add //Me coloco en la primera posicion que tiene valores del arreglo.
2//Posición donde irá el valor en el arreglo.
add //Obtengo la posición donde irá el valor
0
//VALOR.
set_global $calc
//INICIALIZAR ARREGLO CON VALORES DE LA FORMA DE {}{}{}{}------------------.....------
get_local 0 //Posicion actual puntero pila
0
add
get_local $calc //Posicion donde inicia el arreglo.
1//Numero de dimensiones
add //Me coloco en la primera posicion que tiene valores del arreglo.
3//Posición donde irá el valor en el arreglo.
add //Obtengo la posición donde irá el valor
9
//VALOR.
set_global $calc
//INICIALIZAR ARREGLO CON VALORES DE LA FORMA DE {}{}{}{}------------------.....------
get_local 0 //Posicion actual puntero pila
0
add
get_local $calc //Posicion donde inicia el arreglo.
1//Numero de dimensiones
add //Me coloco en la primera posicion que tiene valores del arreglo.
4//Posición donde irá el valor en el arreglo.
add //Obtengo la posición donde irá el valor
4
//VALOR.
set_global $calc
//INICIALIZAR ARREGLO CON VALORES DE LA FORMA DE {}{}{}{}------------------.....------
get_local 0 //Posicion actual puntero pila
0
add
get_local $calc //Posicion donde inicia el arreglo.
1//Numero de dimensiones
add //Me coloco en la primera posicion que tiene valores del arreglo.
5//Posición donde irá el valor en el arreglo.
add //Obtengo la posición donde irá el valor
0
//VALOR.
set_global $calc
//INICIALIZAR ARREGLO CON VALORES DE LA FORMA DE {}{}{}{}------------------.....------
get_local 0 //Posicion actual puntero pila
0
add
get_local $calc //Posicion donde inicia el arreglo.
1//Numero de dimensiones
add //Me coloco en la primera posicion que tiene valores del arreglo.
6//Posición donde irá el valor en el arreglo.
add //Obtengo la posición donde irá el valor
2
//VALOR.
set_global $calc
//INICIALIZAR ARREGLO CON VALORES DE LA FORMA DE {}{}{}{}------------------.....------
get_local 0 //Posicion actual puntero pila
0
add
get_local $calc //Posicion donde inicia el arreglo.
1//Numero de dimensiones
add //Me coloco en la primera posicion que tiene valores del arreglo.
7//Posición donde irá el valor en el arreglo.
add //Obtengo la posición donde irá el valor
6
//VALOR.
set_global $calc
//INICIALIZAR ARREGLO CON VALORES DE LA FORMA DE {}{}{}{}------------------.....------
get_local 0 //Posicion actual puntero pila
0
add
get_local $calc //Posicion donde inicia el arreglo.
1//Numero de dimensiones
add //Me coloco en la primera posicion que tiene valores del arreglo.
8//Posición donde irá el valor en el arreglo.
add //Obtengo la posición donde irá el valor
0
//VALOR.
set_global $calc
//INICIALIZAR ARREGLO CON VALORES DE LA FORMA DE {}{}{}{}------------------.....------
get_local 0 //Posicion actual puntero pila
0
add
get_local $calc //Posicion donde inicia el arreglo.
1//Numero de dimensiones
add //Me coloco en la primera posicion que tiene valores del arreglo.
9//Posición donde irá el valor en el arreglo.
add //Obtengo la posición donde irá el valor
0
//VALOR.
set_global $calc
//INICIALIZAR ARREGLO CON VALORES DE LA FORMA DE {}{}{}{}------------------.....------
get_local 0 //Posicion actual puntero pila
0
add
get_local $calc //Posicion donde inicia el arreglo.
1//Numero de dimensiones
add //Me coloco en la primera posicion que tiene valores del arreglo.
10//Posición donde irá el valor en el arreglo.
add //Obtengo la posición donde irá el valor
1
//VALOR.
set_global $calc
//INICIALIZAR ARREGLO CON VALORES DE LA FORMA DE {}{}{}{}------------------.....------
get_local 0 //Posicion actual puntero pila
0
add
get_local $calc //Posicion donde inicia el arreglo.
1//Numero de dimensiones
add //Me coloco en la primera posicion que tiene valores del arreglo.
11//Posición donde irá el valor en el arreglo.
add //Obtengo la posición donde irá el valor
0
//VALOR.
set_global $calc
//INICIALIZAR ARREGLO CON VALORES DE LA FORMA DE {}{}{}{}------------------.....------
get_local 0 //Posicion actual puntero pila
0
add
get_local $calc //Posicion donde inicia el arreglo.
1//Numero de dimensiones
add //Me coloco en la primera posicion que tiene valores del arreglo.
12//Posición donde irá el valor en el arreglo.
add //Obtengo la posición donde irá el valor
1
//VALOR.
set_global $calc
get_local 0 //Apuntador de la pila
1//Posición donde se encuentra la variable del arreglo
add //Posición donde se guardará en la pila
 get_global 0 //Posición inicial del arreglo en el heap
set_local $calc //Se coloca el valor del puntero del heap en el stack
 
//....RESERVAR ARREGLO....

//----DECLARACION DE LA VARAIBLE QUE LLEVARÁ EL ITERADOR: i
get_local 0   //posicion actual en el puntero de la pila
2  //posición de la variable en la pila
add   //colocar la posición de la variable en la pilita
0 //valor inicial del iterador
set_local $calc   //asignación del valor en la pila
get_local 0   //posicion actual en el puntero de la pila
3  //posición de la variable en la pila
add   //colocar la posición de la variable en la pilita
//MULTIPLICACIÓN DE LAS DIMENSIONES PARA CALCULAR SU TAMAÑO.
13
set_local $calc   //asignación del valor en la pila
//--Guardar el valor de las dimensiones al inicio del arreglo.
get_global 0
13
set_global $calc
get_global 0
1 
add 
set_global 0
$l12:     //Inicio del ciclo. 
//----CONDICIÓN DEL CICLO i < base: i
get_local 0
2
add
get_local $calc

get_local 0
3
add
get_local $calc

Lt
Eqz   // Se valida que la condición haya sido verdadera.
Br_if $l13   //Si es verdadera, hace un goto a la etiqueta verdadera.
Br $l14  //Si la condición es falsa, hace un goto a la etiqueta falsa.
$l13:  //Inicio de la lista de instrucciones. 
//----heap[i] el valor 
get_global 0  //Puntero actual del heap
0  //Valor inicial en la posición h[i]
set_global $calc  //Guardar valor inicial
//---H = H+1
get_global 0 //valor actual del puntero del heap
1 //Aumenta el puntero un tamaño en uno.
add //Aumento del puntero
set_global 0 //se actualiza el valor del puntero del heap.
//----ITERADOR = ITERADOR + 1
get_local 0
2
add
get_local 0
2
add
get_local $calc

1
Add
set_local $calc
Br $l12  //Al finalizar el ciclo, se hace un goto a la etiqueta de inicio del ciclo.
$l14:  // Inicio de la etiqueta falsa o de salida del ciclo. 


//.....FIN ARREGLO.....
//INICIALIZAR ARREGLO CON VALORES DE LA FORMA DE {}{}{}{}------------------.....------
get_local 0 //Posicion actual puntero pila
1
add
get_local $calc //Posicion donde inicia el arreglo.
1//Numero de dimensiones
add //Me coloco en la primera posicion que tiene valores del arreglo.
0//Posición donde irá el valor en el arreglo.
add //Obtengo la posición donde irá el valor
1
//VALOR.
set_global $calc
//INICIALIZAR ARREGLO CON VALORES DE LA FORMA DE {}{}{}{}------------------.....------
get_local 0 //Posicion actual puntero pila
1
add
get_local $calc //Posicion donde inicia el arreglo.
1//Numero de dimensiones
add //Me coloco en la primera posicion que tiene valores del arreglo.
1//Posición donde irá el valor en el arreglo.
add //Obtengo la posición donde irá el valor
2
//VALOR.
set_global $calc
//INICIALIZAR ARREGLO CON VALORES DE LA FORMA DE {}{}{}{}------------------.....------
get_local 0 //Posicion actual puntero pila
1
add
get_local $calc //Posicion donde inicia el arreglo.
1//Numero de dimensiones
add //Me coloco en la primera posicion que tiene valores del arreglo.
2//Posición donde irá el valor en el arreglo.
add //Obtengo la posición donde irá el valor
3
//VALOR.
set_global $calc
//INICIALIZAR ARREGLO CON VALORES DE LA FORMA DE {}{}{}{}------------------.....------
get_local 0 //Posicion actual puntero pila
1
add
get_local $calc //Posicion donde inicia el arreglo.
1//Numero de dimensiones
add //Me coloco en la primera posicion que tiene valores del arreglo.
3//Posición donde irá el valor en el arreglo.
add //Obtengo la posición donde irá el valor
9
//VALOR.
set_global $calc
//INICIALIZAR ARREGLO CON VALORES DE LA FORMA DE {}{}{}{}------------------.....------
get_local 0 //Posicion actual puntero pila
1
add
get_local $calc //Posicion donde inicia el arreglo.
1//Numero de dimensiones
add //Me coloco en la primera posicion que tiene valores del arreglo.
4//Posición donde irá el valor en el arreglo.
add //Obtengo la posición donde irá el valor
4
//VALOR.
set_global $calc
//INICIALIZAR ARREGLO CON VALORES DE LA FORMA DE {}{}{}{}------------------.....------
get_local 0 //Posicion actual puntero pila
1
add
get_local $calc //Posicion donde inicia el arreglo.
1//Numero de dimensiones
add //Me coloco en la primera posicion que tiene valores del arreglo.
5//Posición donde irá el valor en el arreglo.
add //Obtengo la posición donde irá el valor
0
//VALOR.
set_global $calc
//INICIALIZAR ARREGLO CON VALORES DE LA FORMA DE {}{}{}{}------------------.....------
get_local 0 //Posicion actual puntero pila
1
add
get_local $calc //Posicion donde inicia el arreglo.
1//Numero de dimensiones
add //Me coloco en la primera posicion que tiene valores del arreglo.
6//Posición donde irá el valor en el arreglo.
add //Obtengo la posición donde irá el valor
2
//VALOR.
set_global $calc
//INICIALIZAR ARREGLO CON VALORES DE LA FORMA DE {}{}{}{}------------------.....------
get_local 0 //Posicion actual puntero pila
1
add
get_local $calc //Posicion donde inicia el arreglo.
1//Numero de dimensiones
add //Me coloco en la primera posicion que tiene valores del arreglo.
7//Posición donde irá el valor en el arreglo.
add //Obtengo la posición donde irá el valor
6
//VALOR.
set_global $calc
//INICIALIZAR ARREGLO CON VALORES DE LA FORMA DE {}{}{}{}------------------.....------
get_local 0 //Posicion actual puntero pila
1
add
get_local $calc //Posicion donde inicia el arreglo.
1//Numero de dimensiones
add //Me coloco en la primera posicion que tiene valores del arreglo.
8//Posición donde irá el valor en el arreglo.
add //Obtengo la posición donde irá el valor
4
//VALOR.
set_global $calc
//INICIALIZAR ARREGLO CON VALORES DE LA FORMA DE {}{}{}{}------------------.....------
get_local 0 //Posicion actual puntero pila
1
add
get_local $calc //Posicion donde inicia el arreglo.
1//Numero de dimensiones
add //Me coloco en la primera posicion que tiene valores del arreglo.
9//Posición donde irá el valor en el arreglo.
add //Obtengo la posición donde irá el valor
5
//VALOR.
set_global $calc
//INICIALIZAR ARREGLO CON VALORES DE LA FORMA DE {}{}{}{}------------------.....------
get_local 0 //Posicion actual puntero pila
1
add
get_local $calc //Posicion donde inicia el arreglo.
1//Numero de dimensiones
add //Me coloco en la primera posicion que tiene valores del arreglo.
10//Posición donde irá el valor en el arreglo.
add //Obtengo la posición donde irá el valor
1
//VALOR.
set_global $calc
//INICIALIZAR ARREGLO CON VALORES DE LA FORMA DE {}{}{}{}------------------.....------
get_local 0 //Posicion actual puntero pila
1
add
get_local $calc //Posicion donde inicia el arreglo.
1//Numero de dimensiones
add //Me coloco en la primera posicion que tiene valores del arreglo.
11//Posición donde irá el valor en el arreglo.
add //Obtengo la posición donde irá el valor
0
//VALOR.
set_global $calc
//INICIALIZAR ARREGLO CON VALORES DE LA FORMA DE {}{}{}{}------------------.....------
get_local 0 //Posicion actual puntero pila
1
add
get_local $calc //Posicion donde inicia el arreglo.
1//Numero de dimensiones
add //Me coloco en la primera posicion que tiene valores del arreglo.
12//Posición donde irá el valor en el arreglo.
add //Obtengo la posición donde irá el valor
1
//VALOR.
set_global $calc
get_local 0 //Apuntador de la pila
2//Posición donde se encuentra la variable del arreglo
add //Posición donde se guardará en la pila
 get_global 0 //Posición inicial del arreglo en el heap
set_local $calc //Se coloca el valor del puntero del heap en el stack
 
//....RESERVAR ARREGLO....

//----DECLARACION DE LA VARAIBLE QUE LLEVARÁ EL ITERADOR: i
get_local 0   //posicion actual en el puntero de la pila
3  //posición de la variable en la pila
add   //colocar la posición de la variable en la pilita
0 //valor inicial del iterador
set_local $calc   //asignación del valor en la pila
get_local 0   //posicion actual en el puntero de la pila
4  //posición de la variable en la pila
add   //colocar la posición de la variable en la pilita
//MULTIPLICACIÓN DE LAS DIMENSIONES PARA CALCULAR SU TAMAÑO.
13
set_local $calc   //asignación del valor en la pila
//--Guardar el valor de las dimensiones al inicio del arreglo.
get_global 0
13
set_global $calc
get_global 0
1 
add 
set_global 0
$l15:     //Inicio del ciclo. 
//----CONDICIÓN DEL CICLO i < base: i
get_local 0
3
add
get_local $calc

get_local 0
4
add
get_local $calc

Lt
Eqz   // Se valida que la condición haya sido verdadera.
Br_if $l16   //Si es verdadera, hace un goto a la etiqueta verdadera.
Br $l17  //Si la condición es falsa, hace un goto a la etiqueta falsa.
$l16:  //Inicio de la lista de instrucciones. 
//----heap[i] el valor 
get_global 0  //Puntero actual del heap
0  //Valor inicial en la posición h[i]
set_global $calc  //Guardar valor inicial
//---H = H+1
get_global 0 //valor actual del puntero del heap
1 //Aumenta el puntero un tamaño en uno.
add //Aumento del puntero
set_global 0 //se actualiza el valor del puntero del heap.
//----ITERADOR = ITERADOR + 1
get_local 0
3
add
get_local 0
3
add
get_local $calc

1
Add
set_local $calc
Br $l15  //Al finalizar el ciclo, se hace un goto a la etiqueta de inicio del ciclo.
$l17:  // Inicio de la etiqueta falsa o de salida del ciclo. 


//.....FIN ARREGLO.....
//INICIALIZAR ARREGLO CON VALORES DE LA FORMA DE {}{}{}{}------------------.....------
get_local 0 //Posicion actual puntero pila
2
add
get_local $calc //Posicion donde inicia el arreglo.
1//Numero de dimensiones
add //Me coloco en la primera posicion que tiene valores del arreglo.
0//Posición donde irá el valor en el arreglo.
add //Obtengo la posición donde irá el valor
9
//VALOR.
set_global $calc
//INICIALIZAR ARREGLO CON VALORES DE LA FORMA DE {}{}{}{}------------------.....------
get_local 0 //Posicion actual puntero pila
2
add
get_local $calc //Posicion donde inicia el arreglo.
1//Numero de dimensiones
add //Me coloco en la primera posicion que tiene valores del arreglo.
1//Posición donde irá el valor en el arreglo.
add //Obtengo la posición donde irá el valor
8
//VALOR.
set_global $calc
//INICIALIZAR ARREGLO CON VALORES DE LA FORMA DE {}{}{}{}------------------.....------
get_local 0 //Posicion actual puntero pila
2
add
get_local $calc //Posicion donde inicia el arreglo.
1//Numero de dimensiones
add //Me coloco en la primera posicion que tiene valores del arreglo.
2//Posición donde irá el valor en el arreglo.
add //Obtengo la posición donde irá el valor
7
//VALOR.
set_global $calc
//INICIALIZAR ARREGLO CON VALORES DE LA FORMA DE {}{}{}{}------------------.....------
get_local 0 //Posicion actual puntero pila
2
add
get_local $calc //Posicion donde inicia el arreglo.
1//Numero de dimensiones
add //Me coloco en la primera posicion que tiene valores del arreglo.
3//Posición donde irá el valor en el arreglo.
add //Obtengo la posición donde irá el valor
9
//VALOR.
set_global $calc
//INICIALIZAR ARREGLO CON VALORES DE LA FORMA DE {}{}{}{}------------------.....------
get_local 0 //Posicion actual puntero pila
2
add
get_local $calc //Posicion donde inicia el arreglo.
1//Numero de dimensiones
add //Me coloco en la primera posicion que tiene valores del arreglo.
4//Posición donde irá el valor en el arreglo.
add //Obtengo la posición donde irá el valor
4
//VALOR.
set_global $calc
//INICIALIZAR ARREGLO CON VALORES DE LA FORMA DE {}{}{}{}------------------.....------
get_local 0 //Posicion actual puntero pila
2
add
get_local $calc //Posicion donde inicia el arreglo.
1//Numero de dimensiones
add //Me coloco en la primera posicion que tiene valores del arreglo.
5//Posición donde irá el valor en el arreglo.
add //Obtengo la posición donde irá el valor
0
//VALOR.
set_global $calc
//INICIALIZAR ARREGLO CON VALORES DE LA FORMA DE {}{}{}{}------------------.....------
get_local 0 //Posicion actual puntero pila
2
add
get_local $calc //Posicion donde inicia el arreglo.
1//Numero de dimensiones
add //Me coloco en la primera posicion que tiene valores del arreglo.
6//Posición donde irá el valor en el arreglo.
add //Obtengo la posición donde irá el valor
2
//VALOR.
set_global $calc
//INICIALIZAR ARREGLO CON VALORES DE LA FORMA DE {}{}{}{}------------------.....------
get_local 0 //Posicion actual puntero pila
2
add
get_local $calc //Posicion donde inicia el arreglo.
1//Numero de dimensiones
add //Me coloco en la primera posicion que tiene valores del arreglo.
7//Posición donde irá el valor en el arreglo.
add //Obtengo la posición donde irá el valor
6
//VALOR.
set_global $calc
//INICIALIZAR ARREGLO CON VALORES DE LA FORMA DE {}{}{}{}------------------.....------
get_local 0 //Posicion actual puntero pila
2
add
get_local $calc //Posicion donde inicia el arreglo.
1//Numero de dimensiones
add //Me coloco en la primera posicion que tiene valores del arreglo.
8//Posición donde irá el valor en el arreglo.
add //Obtengo la posición donde irá el valor
0
//VALOR.
set_global $calc
//INICIALIZAR ARREGLO CON VALORES DE LA FORMA DE {}{}{}{}------------------.....------
get_local 0 //Posicion actual puntero pila
2
add
get_local $calc //Posicion donde inicia el arreglo.
1//Numero de dimensiones
add //Me coloco en la primera posicion que tiene valores del arreglo.
9//Posición donde irá el valor en el arreglo.
add //Obtengo la posición donde irá el valor
0
//VALOR.
set_global $calc
//INICIALIZAR ARREGLO CON VALORES DE LA FORMA DE {}{}{}{}------------------.....------
get_local 0 //Posicion actual puntero pila
2
add
get_local $calc //Posicion donde inicia el arreglo.
1//Numero de dimensiones
add //Me coloco en la primera posicion que tiene valores del arreglo.
10//Posición donde irá el valor en el arreglo.
add //Obtengo la posición donde irá el valor
1
//VALOR.
set_global $calc
//INICIALIZAR ARREGLO CON VALORES DE LA FORMA DE {}{}{}{}------------------.....------
get_local 0 //Posicion actual puntero pila
2
add
get_local $calc //Posicion donde inicia el arreglo.
1//Numero de dimensiones
add //Me coloco en la primera posicion que tiene valores del arreglo.
11//Posición donde irá el valor en el arreglo.
add //Obtengo la posición donde irá el valor
0
//VALOR.
set_global $calc
//INICIALIZAR ARREGLO CON VALORES DE LA FORMA DE {}{}{}{}------------------.....------
get_local 0 //Posicion actual puntero pila
2
add
get_local $calc //Posicion donde inicia el arreglo.
1//Numero de dimensiones
add //Me coloco en la primera posicion que tiene valores del arreglo.
12//Posición donde irá el valor en el arreglo.
add //Obtengo la posición donde irá el valor
1
//VALOR.
set_global $calc
get_local 0 //Apuntador de la pila
3//Posición donde se encuentra la variable del arreglo
add //Posición donde se guardará en la pila
 get_global 0 //Posición inicial del arreglo en el heap
set_local $calc //Se coloca el valor del puntero del heap en el stack
 
//....RESERVAR ARREGLO....

//----DECLARACION DE LA VARAIBLE QUE LLEVARÁ EL ITERADOR: i
get_local 0   //posicion actual en el puntero de la pila
4  //posición de la variable en la pila
add   //colocar la posición de la variable en la pilita
0 //valor inicial del iterador
set_local $calc   //asignación del valor en la pila
get_local 0   //posicion actual en el puntero de la pila
5  //posición de la variable en la pila
add   //colocar la posición de la variable en la pilita
//MULTIPLICACIÓN DE LAS DIMENSIONES PARA CALCULAR SU TAMAÑO.
13
set_local $calc   //asignación del valor en la pila
//--Guardar el valor de las dimensiones al inicio del arreglo.
get_global 0
13
set_global $calc
get_global 0
1 
add 
set_global 0
$l18:     //Inicio del ciclo. 
//----CONDICIÓN DEL CICLO i < base: i
get_local 0
4
add
get_local $calc

get_local 0
5
add
get_local $calc

Lt
Eqz   // Se valida que la condición haya sido verdadera.
Br_if $l19   //Si es verdadera, hace un goto a la etiqueta verdadera.
Br $l20  //Si la condición es falsa, hace un goto a la etiqueta falsa.
$l19:  //Inicio de la lista de instrucciones. 
//----heap[i] el valor 
get_global 0  //Puntero actual del heap
0  //Valor inicial en la posición h[i]
set_global $calc  //Guardar valor inicial
//---H = H+1
get_global 0 //valor actual del puntero del heap
1 //Aumenta el puntero un tamaño en uno.
add //Aumento del puntero
set_global 0 //se actualiza el valor del puntero del heap.
//----ITERADOR = ITERADOR + 1
get_local 0
4
add
get_local 0
4
add
get_local $calc

1
Add
set_local $calc
Br $l18  //Al finalizar el ciclo, se hace un goto a la etiqueta de inicio del ciclo.
$l20:  // Inicio de la etiqueta falsa o de salida del ciclo. 


//.....FIN ARREGLO.....
//INICIALIZAR ARREGLO CON VALORES DE LA FORMA DE {}{}{}{}------------------.....------
get_local 0 //Posicion actual puntero pila
3
add
get_local $calc //Posicion donde inicia el arreglo.
1//Numero de dimensiones
add //Me coloco en la primera posicion que tiene valores del arreglo.
0//Posición donde irá el valor en el arreglo.
add //Obtengo la posición donde irá el valor
5
//VALOR.
set_global $calc
//INICIALIZAR ARREGLO CON VALORES DE LA FORMA DE {}{}{}{}------------------.....------
get_local 0 //Posicion actual puntero pila
3
add
get_local $calc //Posicion donde inicia el arreglo.
1//Numero de dimensiones
add //Me coloco en la primera posicion que tiene valores del arreglo.
1//Posición donde irá el valor en el arreglo.
add //Obtengo la posición donde irá el valor
6
//VALOR.
set_global $calc
//INICIALIZAR ARREGLO CON VALORES DE LA FORMA DE {}{}{}{}------------------.....------
get_local 0 //Posicion actual puntero pila
3
add
get_local $calc //Posicion donde inicia el arreglo.
1//Numero de dimensiones
add //Me coloco en la primera posicion que tiene valores del arreglo.
2//Posición donde irá el valor en el arreglo.
add //Obtengo la posición donde irá el valor
7
//VALOR.
set_global $calc
//INICIALIZAR ARREGLO CON VALORES DE LA FORMA DE {}{}{}{}------------------.....------
get_local 0 //Posicion actual puntero pila
3
add
get_local $calc //Posicion donde inicia el arreglo.
1//Numero de dimensiones
add //Me coloco en la primera posicion que tiene valores del arreglo.
3//Posición donde irá el valor en el arreglo.
add //Obtengo la posición donde irá el valor
9
//VALOR.
set_global $calc
//INICIALIZAR ARREGLO CON VALORES DE LA FORMA DE {}{}{}{}------------------.....------
get_local 0 //Posicion actual puntero pila
3
add
get_local $calc //Posicion donde inicia el arreglo.
1//Numero de dimensiones
add //Me coloco en la primera posicion que tiene valores del arreglo.
4//Posición donde irá el valor en el arreglo.
add //Obtengo la posición donde irá el valor
4
//VALOR.
set_global $calc
//INICIALIZAR ARREGLO CON VALORES DE LA FORMA DE {}{}{}{}------------------.....------
get_local 0 //Posicion actual puntero pila
3
add
get_local $calc //Posicion donde inicia el arreglo.
1//Numero de dimensiones
add //Me coloco en la primera posicion que tiene valores del arreglo.
5//Posición donde irá el valor en el arreglo.
add //Obtengo la posición donde irá el valor
0
//VALOR.
set_global $calc
//INICIALIZAR ARREGLO CON VALORES DE LA FORMA DE {}{}{}{}------------------.....------
get_local 0 //Posicion actual puntero pila
3
add
get_local $calc //Posicion donde inicia el arreglo.
1//Numero de dimensiones
add //Me coloco en la primera posicion que tiene valores del arreglo.
6//Posición donde irá el valor en el arreglo.
add //Obtengo la posición donde irá el valor
2
//VALOR.
set_global $calc
//INICIALIZAR ARREGLO CON VALORES DE LA FORMA DE {}{}{}{}------------------.....------
get_local 0 //Posicion actual puntero pila
3
add
get_local $calc //Posicion donde inicia el arreglo.
1//Numero de dimensiones
add //Me coloco en la primera posicion que tiene valores del arreglo.
7//Posición donde irá el valor en el arreglo.
add //Obtengo la posición donde irá el valor
6
//VALOR.
set_global $calc
//INICIALIZAR ARREGLO CON VALORES DE LA FORMA DE {}{}{}{}------------------.....------
get_local 0 //Posicion actual puntero pila
3
add
get_local $calc //Posicion donde inicia el arreglo.
1//Numero de dimensiones
add //Me coloco en la primera posicion que tiene valores del arreglo.
8//Posición donde irá el valor en el arreglo.
add //Obtengo la posición donde irá el valor
0
//VALOR.
set_global $calc
//INICIALIZAR ARREGLO CON VALORES DE LA FORMA DE {}{}{}{}------------------.....------
get_local 0 //Posicion actual puntero pila
3
add
get_local $calc //Posicion donde inicia el arreglo.
1//Numero de dimensiones
add //Me coloco en la primera posicion que tiene valores del arreglo.
9//Posición donde irá el valor en el arreglo.
add //Obtengo la posición donde irá el valor
0
//VALOR.
set_global $calc
//INICIALIZAR ARREGLO CON VALORES DE LA FORMA DE {}{}{}{}------------------.....------
get_local 0 //Posicion actual puntero pila
3
add
get_local $calc //Posicion donde inicia el arreglo.
1//Numero de dimensiones
add //Me coloco en la primera posicion que tiene valores del arreglo.
10//Posición donde irá el valor en el arreglo.
add //Obtengo la posición donde irá el valor
1
//VALOR.
set_global $calc
//INICIALIZAR ARREGLO CON VALORES DE LA FORMA DE {}{}{}{}------------------.....------
get_local 0 //Posicion actual puntero pila
3
add
get_local $calc //Posicion donde inicia el arreglo.
1//Numero de dimensiones
add //Me coloco en la primera posicion que tiene valores del arreglo.
11//Posición donde irá el valor en el arreglo.
add //Obtengo la posición donde irá el valor
0
//VALOR.
set_global $calc
//INICIALIZAR ARREGLO CON VALORES DE LA FORMA DE {}{}{}{}------------------.....------
get_local 0 //Posicion actual puntero pila
3
add
get_local $calc //Posicion donde inicia el arreglo.
1//Numero de dimensiones
add //Me coloco en la primera posicion que tiene valores del arreglo.
12//Posición donde irá el valor en el arreglo.
add //Obtengo la posición donde irá el valor
1
//VALOR.
set_global $calc
//INDICE.
0
//TAMAÑO.
1//posicion de la variable del arreglo. 
get_global $calc //Obtiene el valor de la posición del arreglo en el heap.
0//numero de dimensión
add 
get_global $calc //Obtiene el valor de la posición del heap. 
Lt //Valor_Indice < Tamaño_Dimension
Eqz //Valida si es menor
br_if $l21   //salto etiqueta verdadero
br $error_arreglo  //goto etiqueta falso
$l21:    //inicio etiqueta verdadero
1//posicion de la variable del arreglo. 
get_global $calc //Obtiene el valor de la posición del arreglo en el heap.
1
add 
0

add //Se suma la posicion del arreglo.
//INICIO DE LA FUNCIÓN: PASO DE PARAMETROS--------------------
get_local 0
0
add 
5
add 
//--GUARDAR STRING: Se guarda el puntero del heap el numero de veces del tamaño de la cadena.
get_global 0 //Posicion que quedará hasta el final de la cadena.
get_global 0 
68 //Caracter en ASCII 
tee_global $calc //Se guarda el valor en el stack
1 //Posición del caracter 
add 
97 //Caracter en ASCII 
tee_global $calc //Se guarda el valor en el stack
1 //Posición del caracter 
add 
110 //Caracter en ASCII 
tee_global $calc //Se guarda el valor en el stack
1 //Posición del caracter 
add 
105 //Caracter en ASCII 
tee_global $calc //Se guarda el valor en el stack
1 //Posición del caracter 
add 
101 //Caracter en ASCII 
tee_global $calc //Se guarda el valor en el stack
1 //Posición del caracter 
add 
108 //Caracter en ASCII 
tee_global $calc //Se guarda el valor en el stack
1 //Posición del caracter 
add 
92//Caracter ACII final cadena
tee_global $calc //Se guarda el valor en el stack
1 //Posición del caracter 
add 
set_global 0 //Actualizar valor del puntero 
set_local $calc
get_local 0
1
add 
5
add 
21
set_local $calc
get_local 0
2
add 
5
add 
1.71
set_local $calc
get_local 0
3
add 
5
add 
68
set_local $calc
get_local 0
4
add 
5
add 
get_local 0
0
add
get_local $calc
set_local $calc
//CAMBIO AMBITO AUMENTO PILA---------------------------
get_local 0 //Coloca el valor del puntero al inicio de la pilita
5//Coloca el valor del tamaño de la función al inicio de la pilita.
add //Suma el valor actual del puntero el tamaño de la función.
set_local 0 //Se cambia el valor del puntero en la stack
call $Informacion_STRING_INT_DOUBLE_CHAR_INT//se hace la llamada a la función para mover puntero IP
//RETORNO DE LA FUNCION-------------
get_local 0 //Se coloca el puntero al inicio de la pilita
6
add  //se suma el valor que corresponde a la posición del retorno
get_local $calc  //Coloca el valor del retorno en la pilita
//REGRESAR PUNTERO PILA-------------------------------
get_local 0   //Se coloca el puntero al inicio de la pilita
5  //Coloca el valor del tamaño de la función al inicio de la pilita.
diff   //Resta el valo actual del puntero el tamaño de la función para retornar el ambito.
set_local 0  //Se regresa el valor del puntero en la stack.
set_global $calc //ASIGNAR VALOR EN LA POSICIÓN DEL ARREGLO.
//INDICE.
1
//TAMAÑO.
1//posicion de la variable del arreglo. 
get_global $calc //Obtiene el valor de la posición del arreglo en el heap.
0//numero de dimensión
add 
get_global $calc //Obtiene el valor de la posición del heap. 
Lt //Valor_Indice < Tamaño_Dimension
Eqz //Valida si es menor
br_if $l22   //salto etiqueta verdadero
br $error_arreglo  //goto etiqueta falso
$l22:    //inicio etiqueta verdadero
1//posicion de la variable del arreglo. 
get_global $calc //Obtiene el valor de la posición del arreglo en el heap.
1
add 
1

add //Se suma la posicion del arreglo.
//INICIO DE LA FUNCIÓN: PASO DE PARAMETROS--------------------
get_local 0
0
add 
5
add 
//--GUARDAR STRING: Se guarda el puntero del heap el numero de veces del tamaño de la cadena.
get_global 0 //Posicion que quedará hasta el final de la cadena.
get_global 0 
69 //Caracter en ASCII 
tee_global $calc //Se guarda el valor en el stack
1 //Posición del caracter 
add 
100 //Caracter en ASCII 
tee_global $calc //Se guarda el valor en el stack
1 //Posición del caracter 
add 
117 //Caracter en ASCII 
tee_global $calc //Se guarda el valor en el stack
1 //Posición del caracter 
add 
97 //Caracter en ASCII 
tee_global $calc //Se guarda el valor en el stack
1 //Posición del caracter 
add 
114 //Caracter en ASCII 
tee_global $calc //Se guarda el valor en el stack
1 //Posición del caracter 
add 
100 //Caracter en ASCII 
tee_global $calc //Se guarda el valor en el stack
1 //Posición del caracter 
add 
111 //Caracter en ASCII 
tee_global $calc //Se guarda el valor en el stack
1 //Posición del caracter 
add 
92//Caracter ACII final cadena
tee_global $calc //Se guarda el valor en el stack
1 //Posición del caracter 
add 
set_global 0 //Actualizar valor del puntero 
set_local $calc
get_local 0
1
add 
5
add 
22
set_local $calc
get_local 0
2
add 
5
add 
2.71
set_local $calc
get_local 0
3
add 
5
add 
69
set_local $calc
get_local 0
4
add 
5
add 
get_local 0
1
add
get_local $calc
set_local $calc
//CAMBIO AMBITO AUMENTO PILA---------------------------
get_local 0 //Coloca el valor del puntero al inicio de la pilita
5//Coloca el valor del tamaño de la función al inicio de la pilita.
add //Suma el valor actual del puntero el tamaño de la función.
set_local 0 //Se cambia el valor del puntero en la stack
call $Informacion_STRING_INT_DOUBLE_CHAR_INT//se hace la llamada a la función para mover puntero IP
//RETORNO DE LA FUNCION-------------
get_local 0 //Se coloca el puntero al inicio de la pilita
6
add  //se suma el valor que corresponde a la posición del retorno
get_local $calc  //Coloca el valor del retorno en la pilita
//REGRESAR PUNTERO PILA-------------------------------
get_local 0   //Se coloca el puntero al inicio de la pilita
5  //Coloca el valor del tamaño de la función al inicio de la pilita.
diff   //Resta el valo actual del puntero el tamaño de la función para retornar el ambito.
set_local 0  //Se regresa el valor del puntero en la stack.
set_global $calc //ASIGNAR VALOR EN LA POSICIÓN DEL ARREGLO.
//INDICE.
2
//TAMAÑO.
1//posicion de la variable del arreglo. 
get_global $calc //Obtiene el valor de la posición del arreglo en el heap.
0//numero de dimensión
add 
get_global $calc //Obtiene el valor de la posición del heap. 
Lt //Valor_Indice < Tamaño_Dimension
Eqz //Valida si es menor
br_if $l23   //salto etiqueta verdadero
br $error_arreglo  //goto etiqueta falso
$l23:    //inicio etiqueta verdadero
1//posicion de la variable del arreglo. 
get_global $calc //Obtiene el valor de la posición del arreglo en el heap.
1
add 
2

add //Se suma la posicion del arreglo.
//INICIO DE LA FUNCIÓN: PASO DE PARAMETROS--------------------
get_local 0
0
add 
5
add 
//--GUARDAR STRING: Se guarda el puntero del heap el numero de veces del tamaño de la cadena.
get_global 0 //Posicion que quedará hasta el final de la cadena.
get_global 0 
71 //Caracter en ASCII 
tee_global $calc //Se guarda el valor en el stack
1 //Posición del caracter 
add 
97 //Caracter en ASCII 
tee_global $calc //Se guarda el valor en el stack
1 //Posición del caracter 
add 
114 //Caracter en ASCII 
tee_global $calc //Se guarda el valor en el stack
1 //Posición del caracter 
add 
99 //Caracter en ASCII 
tee_global $calc //Se guarda el valor en el stack
1 //Posición del caracter 
add 
105 //Caracter en ASCII 
tee_global $calc //Se guarda el valor en el stack
1 //Posición del caracter 
add 
97 //Caracter en ASCII 
tee_global $calc //Se guarda el valor en el stack
1 //Posición del caracter 
add 
92//Caracter ACII final cadena
tee_global $calc //Se guarda el valor en el stack
1 //Posición del caracter 
add 
set_global 0 //Actualizar valor del puntero 
set_local $calc
get_local 0
1
add 
5
add 
23
set_local $calc
get_local 0
2
add 
5
add 
3.71
set_local $calc
get_local 0
3
add 
5
add 
71
set_local $calc
get_local 0
4
add 
5
add 
get_local 0
2
add
get_local $calc
set_local $calc
//CAMBIO AMBITO AUMENTO PILA---------------------------
get_local 0 //Coloca el valor del puntero al inicio de la pilita
5//Coloca el valor del tamaño de la función al inicio de la pilita.
add //Suma el valor actual del puntero el tamaño de la función.
set_local 0 //Se cambia el valor del puntero en la stack
call $Informacion_STRING_INT_DOUBLE_CHAR_INT//se hace la llamada a la función para mover puntero IP
//RETORNO DE LA FUNCION-------------
get_local 0 //Se coloca el puntero al inicio de la pilita
6
add  //se suma el valor que corresponde a la posición del retorno
get_local $calc  //Coloca el valor del retorno en la pilita
//REGRESAR PUNTERO PILA-------------------------------
get_local 0   //Se coloca el puntero al inicio de la pilita
5  //Coloca el valor del tamaño de la función al inicio de la pilita.
diff   //Resta el valo actual del puntero el tamaño de la función para retornar el ambito.
set_local 0  //Se regresa el valor del puntero en la stack.
set_global $calc //ASIGNAR VALOR EN LA POSICIÓN DEL ARREGLO.
//INDICE.
3
//TAMAÑO.
1//posicion de la variable del arreglo. 
get_global $calc //Obtiene el valor de la posición del arreglo en el heap.
0//numero de dimensión
add 
get_global $calc //Obtiene el valor de la posición del heap. 
Lt //Valor_Indice < Tamaño_Dimension
Eqz //Valida si es menor
br_if $l24   //salto etiqueta verdadero
br $error_arreglo  //goto etiqueta falso
$l24:    //inicio etiqueta verdadero
1//posicion de la variable del arreglo. 
get_global $calc //Obtiene el valor de la posición del arreglo en el heap.
1
add 
3

add //Se suma la posicion del arreglo.
//INICIO DE LA FUNCIÓN: PASO DE PARAMETROS--------------------
get_local 0
0
add 
5
add 
//--GUARDAR STRING: Se guarda el puntero del heap el numero de veces del tamaño de la cadena.
get_global 0 //Posicion que quedará hasta el final de la cadena.
get_global 0 
80 //Caracter en ASCII 
tee_global $calc //Se guarda el valor en el stack
1 //Posición del caracter 
add 
97 //Caracter en ASCII 
tee_global $calc //Se guarda el valor en el stack
1 //Posición del caracter 
add 
105 //Caracter en ASCII 
tee_global $calc //Se guarda el valor en el stack
1 //Posición del caracter 
add 
122 //Caracter en ASCII 
tee_global $calc //Se guarda el valor en el stack
1 //Posición del caracter 
add 
92//Caracter ACII final cadena
tee_global $calc //Se guarda el valor en el stack
1 //Posición del caracter 
add 
set_global 0 //Actualizar valor del puntero 
set_local $calc
get_local 0
1
add 
5
add 
24
set_local $calc
get_local 0
2
add 
5
add 
4.71
set_local $calc
get_local 0
3
add 
5
add 
80
set_local $calc
get_local 0
4
add 
5
add 
get_local 0
3
add
get_local $calc
set_local $calc
//CAMBIO AMBITO AUMENTO PILA---------------------------
get_local 0 //Coloca el valor del puntero al inicio de la pilita
5//Coloca el valor del tamaño de la función al inicio de la pilita.
add //Suma el valor actual del puntero el tamaño de la función.
set_local 0 //Se cambia el valor del puntero en la stack
call $Informacion_STRING_INT_DOUBLE_CHAR_INT//se hace la llamada a la función para mover puntero IP
//RETORNO DE LA FUNCION-------------
get_local 0 //Se coloca el puntero al inicio de la pilita
6
add  //se suma el valor que corresponde a la posición del retorno
get_local $calc  //Coloca el valor del retorno en la pilita
//REGRESAR PUNTERO PILA-------------------------------
get_local 0   //Se coloca el puntero al inicio de la pilita
5  //Coloca el valor del tamaño de la función al inicio de la pilita.
diff   //Resta el valo actual del puntero el tamaño de la función para retornar el ambito.
set_local 0  //Se regresa el valor del puntero en la stack.
set_global $calc //ASIGNAR VALOR EN LA POSICIÓN DEL ARREGLO.
//...Inicio declaracion
get_local 0   //posicion actual en el puntero de la pila
4  //posición de la variable en la pila
add   //colocar la posición de la variable en la pilita
0
  //valor inicial de la variable
set_local $calc   //asignación del valor en la pila
//...Fin Declaración
//...........Inicio While
$l25:     //Inicio del ciclo. 
get_local 0
4
add
get_local $calc

4

Lt
    //Codigo de la condición, se asume que el valor de la condición ya está en la pilita.
Eqz   // Se valida que la condición haya sido verdadera.
Br_if $l26   //Si es verdadera, hace un goto a la etiqueta verdadera.
Br $l27  //Si la condición es falsa, hace un goto a la etiqueta falsa.
$l26:  //Inicio de la lista de instrucciones. 
//INICIO DE LA FUNCIÓN: PASO DE PARAMETROS--------------------
get_local 0
0
add 
5
add 
//INDICE.
get_local 0
4
add
get_local $calc
//TAMAÑO.
1//posicion de la variable del arreglo. 
get_global $calc //Obtiene el valor de la posición del arreglo en el heap.
0//numero de dimensión
add 
get_global $calc //Obtiene el valor de la posición del heap. 
Lt //Valor_Indice < Tamaño_Dimension
Eqz //Valida si es menor
br_if $l28   //salto etiqueta verdadero
br $error_arreglo  //goto etiqueta falso
$l28:    //inicio etiqueta verdadero
1//posicion de la variable del arreglo. 
get_global $calc //Obtiene el valor de la posición del arreglo en el heap.
1
add 
get_local 0
4
add
get_local $calc

add //Se suma la posicion del arreglo.
get_global $calc //Se obtiene el valor de la posición del arreglo.
set_local $calc
//CAMBIO AMBITO AUMENTO PILA---------------------------
get_local 0 //Coloca el valor del puntero al inicio de la pilita
5//Coloca el valor del tamaño de la función al inicio de la pilita.
add //Suma el valor actual del puntero el tamaño de la función.
set_local 0 //Se cambia el valor del puntero en la stack
call $imprimir_usuario_Persona//se hace la llamada a la función para mover puntero IP
//REGRESAR PUNTERO PILA-------------------------------
get_local 0   //Se coloca el puntero al inicio de la pilita
5  //Coloca el valor del tamaño de la función al inicio de la pilita.
diff   //Resta el valo actual del puntero el tamaño de la función para retornar el ambito.
set_local 0  //Se regresa el valor del puntero en la stack.
get_local 0 
 4
add 
get_local 0
4
add
get_local $calc

1
add 
set_local $calc
Br $l25  //Al finalizar el ciclo, se hace un goto a la etiqueta de inicio del ciclo.
$l27:  // Inicio de la etiqueta falsa o de salida del ciclo. 
//.......fin while
End
Function $Informacion_STRING_INT_DOUBLE_CHAR_INT
//DECLARACION DE UNA ESTRUCTURA--------------------
get_local 0 //Apuntador de la pila
5//Posición donde se encuentra la variable del struct
add //Posición donde se guardará en la pila
 get_global 0 //Posición inicial del struct en el heap
set_local $calc //Se coloca el valor del puntero del heap en el stack
 get_global 0 //posicion del heap antes de entrar a la declaracion.
get_global 0
5
add 
set_global 0
//DECLARACION EN STRUCT***************
-1//Valor inicial de la variable del struct
tee_global $calc  //asignación del valor en el heap
1
add
//DECLARACION EN STRUCT***************
0//Valor inicial de la variable del struct
tee_global $calc  //asignación del valor en el heap
1
add
//DECLARACION EN STRUCT***************
0//Valor inicial de la variable del struct
tee_global $calc  //asignación del valor en el heap
1
add
//DECLARACION EN STRUCT***************
92//Valor inicial de la variable del struct
tee_global $calc  //asignación del valor en el heap
1
add
//DECLARACION DE ARREGLO EN STRUCT|||||||||||||||||||
get_global 0 //Posición inicial del arreglo en el heap
tee_global $calc //Se coloca el valor del puntero del heap en el heap
 
//....RESERVAR ARREGLO....

//----DECLARACION DE LA VARAIBLE QUE LLEVARÁ EL ITERADOR: i
get_local 0   //posicion actual en el puntero de la pila
6  //posición de la variable en la pila
add   //colocar la posición de la variable en la pilita
0 //valor inicial del iterador
set_local $calc   //asignación del valor en la pila
get_local 0   //posicion actual en el puntero de la pila
7  //posición de la variable en la pila
add   //colocar la posición de la variable en la pilita
//MULTIPLICACIÓN DE LAS DIMENSIONES PARA CALCULAR SU TAMAÑO.
13
set_local $calc   //asignación del valor en la pila
//--Guardar el valor de las dimensiones al inicio del arreglo.
get_global 0
13
set_global $calc
get_global 0
1 
add 
set_global 0
$l29:     //Inicio del ciclo. 
//----CONDICIÓN DEL CICLO i < base: i
get_local 0
6
add
get_local $calc

get_local 0
7
add
get_local $calc

Lt
Eqz   // Se valida que la condición haya sido verdadera.
Br_if $l30   //Si es verdadera, hace un goto a la etiqueta verdadera.
Br $l31  //Si la condición es falsa, hace un goto a la etiqueta falsa.
$l30:  //Inicio de la lista de instrucciones. 
//----heap[i] el valor 
get_global 0  //Puntero actual del heap
0  //Valor inicial en la posición h[i]
set_global $calc  //Guardar valor inicial
//---H = H+1
get_global 0 //valor actual del puntero del heap
1 //Aumenta el puntero un tamaño en uno.
add //Aumento del puntero
set_global 0 //se actualiza el valor del puntero del heap.
//----ITERADOR = ITERADOR + 1
get_local 0
6
add
get_local 0
6
add
get_local $calc

1
Add
set_local $calc
Br $l29  //Al finalizar el ciclo, se hace un goto a la etiqueta de inicio del ciclo.
$l31:  // Inicio de la etiqueta falsa o de salida del ciclo. 
1
add


//.....FIN ARREGLO.....
br_if $l32
$l32:
get_local 0 //puntero actual del stck
5//posición del objeto en el stack
add
get_local $calc //Se obtiene la posición del struct en el heap.
0  //Posición del atributo en el struct
add //Se coloca en la pilita la posición del atributo, listo para asingar.
get_local 0
0
add
get_local $calc

set_global $calc
get_local 0 //puntero actual del stck
5//posición del objeto en el stack
add
get_local $calc //Se obtiene la posición del struct en el heap.
1  //Posición del atributo en el struct
add //Se coloca en la pilita la posición del atributo, listo para asingar.
get_local 0
1
add
get_local $calc

set_global $calc
get_local 0 //puntero actual del stck
5//posición del objeto en el stack
add
get_local $calc //Se obtiene la posición del struct en el heap.
2  //Posición del atributo en el struct
add //Se coloca en la pilita la posición del atributo, listo para asingar.
get_local 0
2
add
get_local $calc

set_global $calc
get_local 0 //puntero actual del stck
5//posición del objeto en el stack
add
get_local $calc //Se obtiene la posición del struct en el heap.
3  //Posición del atributo en el struct
add //Se coloca en la pilita la posición del atributo, listo para asingar.
get_local 0
3
add
get_local $calc

set_global $calc
get_local 0 //puntero actual del stck
5//posición del objeto en el stack
add
get_local $calc //Se obtiene la posición del struct en el heap.
4  //Posición del atributo en el struct
add //Se coloca en la pilita la posición del atributo, listo para asingar.
get_local 0
4
add
get_local $calc

set_global $calc
//....INICIO RETORNO....
get_local 0
6
add 
get_local 0
5
add
get_local $calc
set_local $calc
br $l33//Salida de la función.
//.....FIN RETORNO....
$l33:
End
Function $imprimir_usuario_Persona

//--Función Imprimir

//=============LLAMADA A FUNCIÓN IMPRIMIR===========================

//PARAMETRO1
get_local 0 // me posiciono en el inicio de la función actual.
0// busco la posición del parametro que voy a pasar
add  //Me posicion en el lugar del parametro
2// se coloca el tamaño de la función para poder guardar la variable
add //Se suma el tamaño del ambito para poder pasar el parametro a la posición que lo recibe.
//--GUARDAR STRING: Se guarda el puntero del heap el numero de veces del tamaño de la cadena.
get_global 0 //Posicion que quedará hasta el final de la cadena.
get_global 0 
45 //Caracter en ASCII 
tee_global $calc //Se guarda el valor en el stack
1 //Posición del caracter 
add 
45 //Caracter en ASCII 
tee_global $calc //Se guarda el valor en el stack
1 //Posición del caracter 
add 
45 //Caracter en ASCII 
tee_global $calc //Se guarda el valor en el stack
1 //Posición del caracter 
add 
45 //Caracter en ASCII 
tee_global $calc //Se guarda el valor en el stack
1 //Posición del caracter 
add 
45 //Caracter en ASCII 
tee_global $calc //Se guarda el valor en el stack
1 //Posición del caracter 
add 
45 //Caracter en ASCII 
tee_global $calc //Se guarda el valor en el stack
1 //Posición del caracter 
add 
45 //Caracter en ASCII 
tee_global $calc //Se guarda el valor en el stack
1 //Posición del caracter 
add 
86 //Caracter en ASCII 
tee_global $calc //Se guarda el valor en el stack
1 //Posición del caracter 
add 
65 //Caracter en ASCII 
tee_global $calc //Se guarda el valor en el stack
1 //Posición del caracter 
add 
76 //Caracter en ASCII 
tee_global $calc //Se guarda el valor en el stack
1 //Posición del caracter 
add 
79 //Caracter en ASCII 
tee_global $calc //Se guarda el valor en el stack
1 //Posición del caracter 
add 
82 //Caracter en ASCII 
tee_global $calc //Se guarda el valor en el stack
1 //Posición del caracter 
add 
69 //Caracter en ASCII 
tee_global $calc //Se guarda el valor en el stack
1 //Posición del caracter 
add 
83 //Caracter en ASCII 
tee_global $calc //Se guarda el valor en el stack
1 //Posición del caracter 
add 
32 //Caracter en ASCII 
tee_global $calc //Se guarda el valor en el stack
1 //Posición del caracter 
add 
68 //Caracter en ASCII 
tee_global $calc //Se guarda el valor en el stack
1 //Posición del caracter 
add 
69 //Caracter en ASCII 
tee_global $calc //Se guarda el valor en el stack
1 //Posición del caracter 
add 
32 //Caracter en ASCII 
tee_global $calc //Se guarda el valor en el stack
1 //Posición del caracter 
add 
76 //Caracter en ASCII 
tee_global $calc //Se guarda el valor en el stack
1 //Posición del caracter 
add 
65 //Caracter en ASCII 
tee_global $calc //Se guarda el valor en el stack
1 //Posición del caracter 
add 
32 //Caracter en ASCII 
tee_global $calc //Se guarda el valor en el stack
1 //Posición del caracter 
add 
69 //Caracter en ASCII 
tee_global $calc //Se guarda el valor en el stack
1 //Posición del caracter 
add 
83 //Caracter en ASCII 
tee_global $calc //Se guarda el valor en el stack
1 //Posición del caracter 
add 
84 //Caracter en ASCII 
tee_global $calc //Se guarda el valor en el stack
1 //Posición del caracter 
add 
82 //Caracter en ASCII 
tee_global $calc //Se guarda el valor en el stack
1 //Posición del caracter 
add 
85 //Caracter en ASCII 
tee_global $calc //Se guarda el valor en el stack
1 //Posición del caracter 
add 
67 //Caracter en ASCII 
tee_global $calc //Se guarda el valor en el stack
1 //Posición del caracter 
add 
84 //Caracter en ASCII 
tee_global $calc //Se guarda el valor en el stack
1 //Posición del caracter 
add 
85 //Caracter en ASCII 
tee_global $calc //Se guarda el valor en el stack
1 //Posición del caracter 
add 
82 //Caracter en ASCII 
tee_global $calc //Se guarda el valor en el stack
1 //Posición del caracter 
add 
65 //Caracter en ASCII 
tee_global $calc //Se guarda el valor en el stack
1 //Posición del caracter 
add 
45 //Caracter en ASCII 
tee_global $calc //Se guarda el valor en el stack
1 //Posición del caracter 
add 
45 //Caracter en ASCII 
tee_global $calc //Se guarda el valor en el stack
1 //Posición del caracter 
add 
45 //Caracter en ASCII 
tee_global $calc //Se guarda el valor en el stack
1 //Posición del caracter 
add 
45 //Caracter en ASCII 
tee_global $calc //Se guarda el valor en el stack
1 //Posición del caracter 
add 
45 //Caracter en ASCII 
tee_global $calc //Se guarda el valor en el stack
1 //Posición del caracter 
add 
45 //Caracter en ASCII 
tee_global $calc //Se guarda el valor en el stack
1 //Posición del caracter 
add 
45 //Caracter en ASCII 
tee_global $calc //Se guarda el valor en el stack
1 //Posición del caracter 
add 
92//Caracter ACII final cadena
tee_global $calc //Se guarda el valor en el stack
1 //Posición del caracter 
add 
set_global 0 //Actualizar valor del puntero 
// Traducción del valor que se va a pasar como parametro
set_local $calc //guardo el valor en la posición calculada

//LLAMADA DE LA FUNCIÓN CONCATENAR
get_local 0 //Coloca el valor del puntero al inicio de la pilita
2 //Coloca el valor del tamaño de la función al inicio de la pilita.
add //Suma el valor actual del puntero el tamaño de la función.
set_local 0 //Se cambia el valor del puntero en la stack
call $imprimir_cadena //se hace la llamada a la función para mover puntero IP

//REGRESAR PUNTERO DEL STACK
get_local 0 //Se coloca el puntero al inicio de la pilita
2 //Coloca el valor del tamaño de la función al inicio de la pilita.
diff //Resta el valo actual del puntero el tamaño de la función para retornar el ambito.
set_local 0 //Se regresa el valor del puntero en la stack.
//========================FIN IMPRIMIR==================
%c
//Valor a imprimir...
10
Print

//--Función Imprimir

//=============LLAMADA A FUNCIÓN IMPRIMIR===========================

//PARAMETRO1
get_local 0 // me posiciono en el inicio de la función actual.
0// busco la posición del parametro que voy a pasar
add  //Me posicion en el lugar del parametro
2// se coloca el tamaño de la función para poder guardar la variable
add //Se suma el tamaño del ambito para poder pasar el parametro a la posición que lo recibe.
//--------INICIO CONCATENACIÓN----------

//PARAMETRO1
get_local 0 // me posiciono en el inicio de la función actual.
0// busco la posición del parametro que voy a pasar
add  //Me posicion en el lugar del parametro
2// se coloca el tamaño de la función para poder guardar la variable
add //Se suma el tamaño del ambito para poder pasar el parametro a la posición que lo recibe.
//--GUARDAR STRING: Se guarda el puntero del heap el numero de veces del tamaño de la cadena.
get_global 0 //Posicion que quedará hasta el final de la cadena.
get_global 0 
78 //Caracter en ASCII 
tee_global $calc //Se guarda el valor en el stack
1 //Posición del caracter 
add 
111 //Caracter en ASCII 
tee_global $calc //Se guarda el valor en el stack
1 //Posición del caracter 
add 
109 //Caracter en ASCII 
tee_global $calc //Se guarda el valor en el stack
1 //Posición del caracter 
add 
98 //Caracter en ASCII 
tee_global $calc //Se guarda el valor en el stack
1 //Posición del caracter 
add 
114 //Caracter en ASCII 
tee_global $calc //Se guarda el valor en el stack
1 //Posición del caracter 
add 
101 //Caracter en ASCII 
tee_global $calc //Se guarda el valor en el stack
1 //Posición del caracter 
add 
58 //Caracter en ASCII 
tee_global $calc //Se guarda el valor en el stack
1 //Posición del caracter 
add 
32 //Caracter en ASCII 
tee_global $calc //Se guarda el valor en el stack
1 //Posición del caracter 
add 
92//Caracter ACII final cadena
tee_global $calc //Se guarda el valor en el stack
1 //Posición del caracter 
add 
set_global 0 //Actualizar valor del puntero 
// Traducción del valor que se va a pasar como parametro
set_local $calc //guardo el valor en la posición calculada

//PARAMETRO2
get_local 0 // me posiciono en el inicio de la función actual.
1 // busco la posición del parametro que voy a pasar
add //Me posicion en el lugar del parametro
2// se coloca el tamaño de la función para poder guardar la variable
add //Se suma el tamaño del ambito para poder pasar el parametro a la posición que lo recibe.
get_local 0 
0  //Posición del objeto en la pila.
add //Posición del inicio del struct en el stack
get_local $calc //Obtener valor del apuntador del heap.
0  //Posición del atributo en el struct
add
get_global $calc //Obtener el valor de la posición del heap.
 // Traducción del valor que se va a pasar como parametro
set_local $calc //guardo el valor en la posición calculada

//LLAMADA DE LA FUNCIÓN CONCATENAR
get_local 0 //Coloca el valor del puntero al inicio de la pilita
2 //Coloca el valor del tamaño de la función al inicio de la pilita.
add //Suma el valor actual del puntero el tamaño de la función.
set_local 0 //Se cambia el valor del puntero en la stack
call $ConcatenarString //se hace la llamada a la función para mover puntero IP

//REGRESAR PUNTERO DEL STACK
get_local 0 //Se coloca el puntero al inicio de la pilita
2 //Coloca el valor del tamaño de la función al inicio de la pilita.
diff //Resta el valo actual del puntero el tamaño de la función para retornar el ambito.
set_local 0 //Se regresa el valor del puntero en la stack.
// Traducción del valor que se va a pasar como parametro
set_local $calc //guardo el valor en la posición calculada

//LLAMADA DE LA FUNCIÓN CONCATENAR
get_local 0 //Coloca el valor del puntero al inicio de la pilita
2 //Coloca el valor del tamaño de la función al inicio de la pilita.
add //Suma el valor actual del puntero el tamaño de la función.
set_local 0 //Se cambia el valor del puntero en la stack
call $imprimir_cadena //se hace la llamada a la función para mover puntero IP

//REGRESAR PUNTERO DEL STACK
get_local 0 //Se coloca el puntero al inicio de la pilita
2 //Coloca el valor del tamaño de la función al inicio de la pilita.
diff //Resta el valo actual del puntero el tamaño de la función para retornar el ambito.
set_local 0 //Se regresa el valor del puntero en la stack.
//========================FIN IMPRIMIR==================
%c
//Valor a imprimir...
10
Print

//--Función Imprimir

//=============LLAMADA A FUNCIÓN IMPRIMIR===========================

//PARAMETRO1
get_local 0 // me posiciono en el inicio de la función actual.
0// busco la posición del parametro que voy a pasar
add  //Me posicion en el lugar del parametro
2// se coloca el tamaño de la función para poder guardar la variable
add //Se suma el tamaño del ambito para poder pasar el parametro a la posición que lo recibe.
//--------INICIO CONCATENACIÓN----------

//PARAMETRO1
get_local 0 // me posiciono en el inicio de la función actual.
0// busco la posición del parametro que voy a pasar
add  //Me posicion en el lugar del parametro
2// se coloca el tamaño de la función para poder guardar la variable
add //Se suma el tamaño del ambito para poder pasar el parametro a la posición que lo recibe.
//--GUARDAR STRING: Se guarda el puntero del heap el numero de veces del tamaño de la cadena.
get_global 0 //Posicion que quedará hasta el final de la cadena.
get_global 0 
69 //Caracter en ASCII 
tee_global $calc //Se guarda el valor en el stack
1 //Posición del caracter 
add 
100 //Caracter en ASCII 
tee_global $calc //Se guarda el valor en el stack
1 //Posición del caracter 
add 
97 //Caracter en ASCII 
tee_global $calc //Se guarda el valor en el stack
1 //Posición del caracter 
add 
100 //Caracter en ASCII 
tee_global $calc //Se guarda el valor en el stack
1 //Posición del caracter 
add 
58 //Caracter en ASCII 
tee_global $calc //Se guarda el valor en el stack
1 //Posición del caracter 
add 
32 //Caracter en ASCII 
tee_global $calc //Se guarda el valor en el stack
1 //Posición del caracter 
add 
92//Caracter ACII final cadena
tee_global $calc //Se guarda el valor en el stack
1 //Posición del caracter 
add 
set_global 0 //Actualizar valor del puntero 
// Traducción del valor que se va a pasar como parametro
set_local $calc //guardo el valor en la posición calculada

//PARAMETRO2
get_local 0 // me posiciono en el inicio de la función actual.
1 // busco la posición del parametro que voy a pasar
add //Me posicion en el lugar del parametro
2// se coloca el tamaño de la función para poder guardar la variable
add //Se suma el tamaño del ambito para poder pasar el parametro a la posición que lo recibe.

//=============CONVERTIR VALOR ENTERO A STRING PARA CONCATENAR===========================

//PARAMETRO1
get_local 0 // me posiciono en el inicio de la función actual.
0// busco la posición del parametro que voy a pasar
add  //Me posicion en el lugar del parametro
2// se coloca el tamaño de la función para poder guardar la variable
add //Se suma el tamaño del ambito para poder pasar el parametro a la posición que lo recibe.
1 //POR SER EL SEGUNDO OPERADOR SE SUMA UNO MÁS.
add 
get_local 0 
0  //Posición del objeto en la pila.
add //Posición del inicio del struct en el stack
get_local $calc //Obtener valor del apuntador del heap.
1  //Posición del atributo en el struct
add
get_global $calc //Obtener el valor de la posición del heap.
// Traducción del valor que se va a pasar como parametro
set_local $calc //guardo el valor en la posición calculada

//LLAMADA DE LA FUNCIÓN CONCATENAR
get_local 0 //Coloca el valor del puntero al inicio de la pilita
2 //Coloca el valor del tamaño de la función al inicio de la pilita.
add //Suma el valor actual del puntero el tamaño de la función.
1 //POR SER EL SEGUNDO OPERADOR SE SUMA UNO MÁS.
add 
set_local 0 //Se cambia el valor del puntero en la stack
call $double_to_int //se hace la llamada a la función para mover puntero IP

//REGRESAR PUNTERO DEL STACK
get_local 0 //Se coloca el puntero al inicio de la pilita
2 //Coloca el valor del tamaño de la función al inicio de la pilita.
diff //Resta el valo actual del puntero el tamaño de la función para retornar el ambito.
1 //POR SER EL SEGUNDO OPERADOR SE RESTA UNO MÁS.
diff 
set_local 0 //Se regresa el valor del puntero en la stack.
//========================FIN CONVERSION==================
 // Traducción del valor que se va a pasar como parametro
set_local $calc //guardo el valor en la posición calculada

//LLAMADA DE LA FUNCIÓN CONCATENAR
get_local 0 //Coloca el valor del puntero al inicio de la pilita
2 //Coloca el valor del tamaño de la función al inicio de la pilita.
add //Suma el valor actual del puntero el tamaño de la función.
set_local 0 //Se cambia el valor del puntero en la stack
call $ConcatenarString //se hace la llamada a la función para mover puntero IP

//REGRESAR PUNTERO DEL STACK
get_local 0 //Se coloca el puntero al inicio de la pilita
2 //Coloca el valor del tamaño de la función al inicio de la pilita.
diff //Resta el valo actual del puntero el tamaño de la función para retornar el ambito.
set_local 0 //Se regresa el valor del puntero en la stack.
// Traducción del valor que se va a pasar como parametro
set_local $calc //guardo el valor en la posición calculada

//LLAMADA DE LA FUNCIÓN CONCATENAR
get_local 0 //Coloca el valor del puntero al inicio de la pilita
2 //Coloca el valor del tamaño de la función al inicio de la pilita.
add //Suma el valor actual del puntero el tamaño de la función.
set_local 0 //Se cambia el valor del puntero en la stack
call $imprimir_cadena //se hace la llamada a la función para mover puntero IP

//REGRESAR PUNTERO DEL STACK
get_local 0 //Se coloca el puntero al inicio de la pilita
2 //Coloca el valor del tamaño de la función al inicio de la pilita.
diff //Resta el valo actual del puntero el tamaño de la función para retornar el ambito.
set_local 0 //Se regresa el valor del puntero en la stack.
//========================FIN IMPRIMIR==================
%c
//Valor a imprimir...
10
Print

//--Función Imprimir

//=============LLAMADA A FUNCIÓN IMPRIMIR===========================

//PARAMETRO1
get_local 0 // me posiciono en el inicio de la función actual.
0// busco la posición del parametro que voy a pasar
add  //Me posicion en el lugar del parametro
2// se coloca el tamaño de la función para poder guardar la variable
add //Se suma el tamaño del ambito para poder pasar el parametro a la posición que lo recibe.
//--------INICIO CONCATENACIÓN----------

//PARAMETRO1
get_local 0 // me posiciono en el inicio de la función actual.
0// busco la posición del parametro que voy a pasar
add  //Me posicion en el lugar del parametro
2// se coloca el tamaño de la función para poder guardar la variable
add //Se suma el tamaño del ambito para poder pasar el parametro a la posición que lo recibe.
//--GUARDAR STRING: Se guarda el puntero del heap el numero de veces del tamaño de la cadena.
get_global 0 //Posicion que quedará hasta el final de la cadena.
get_global 0 
69 //Caracter en ASCII 
tee_global $calc //Se guarda el valor en el stack
1 //Posición del caracter 
add 
115 //Caracter en ASCII 
tee_global $calc //Se guarda el valor en el stack
1 //Posición del caracter 
add 
116 //Caracter en ASCII 
tee_global $calc //Se guarda el valor en el stack
1 //Posición del caracter 
add 
97 //Caracter en ASCII 
tee_global $calc //Se guarda el valor en el stack
1 //Posición del caracter 
add 
116 //Caracter en ASCII 
tee_global $calc //Se guarda el valor en el stack
1 //Posición del caracter 
add 
117 //Caracter en ASCII 
tee_global $calc //Se guarda el valor en el stack
1 //Posición del caracter 
add 
114 //Caracter en ASCII 
tee_global $calc //Se guarda el valor en el stack
1 //Posición del caracter 
add 
97 //Caracter en ASCII 
tee_global $calc //Se guarda el valor en el stack
1 //Posición del caracter 
add 
58 //Caracter en ASCII 
tee_global $calc //Se guarda el valor en el stack
1 //Posición del caracter 
add 
32 //Caracter en ASCII 
tee_global $calc //Se guarda el valor en el stack
1 //Posición del caracter 
add 
92//Caracter ACII final cadena
tee_global $calc //Se guarda el valor en el stack
1 //Posición del caracter 
add 
set_global 0 //Actualizar valor del puntero 
// Traducción del valor que se va a pasar como parametro
set_local $calc //guardo el valor en la posición calculada

//PARAMETRO2
get_local 0 // me posiciono en el inicio de la función actual.
1 // busco la posición del parametro que voy a pasar
add //Me posicion en el lugar del parametro
2// se coloca el tamaño de la función para poder guardar la variable
add //Se suma el tamaño del ambito para poder pasar el parametro a la posición que lo recibe.

//=============CONVERTIR VALOR ENTERO A STRING PARA CONCATENAR===========================

//PARAMETRO1
get_local 0 // me posiciono en el inicio de la función actual.
0// busco la posición del parametro que voy a pasar
add  //Me posicion en el lugar del parametro
2// se coloca el tamaño de la función para poder guardar la variable
add //Se suma el tamaño del ambito para poder pasar el parametro a la posición que lo recibe.
1 //POR SER EL SEGUNDO OPERADOR SE SUMA UNO MÁS.
add 
get_local 0 
0  //Posición del objeto en la pila.
add //Posición del inicio del struct en el stack
get_local $calc //Obtener valor del apuntador del heap.
2  //Posición del atributo en el struct
add
get_global $calc //Obtener el valor de la posición del heap.
// Traducción del valor que se va a pasar como parametro
set_local $calc //guardo el valor en la posición calculada

//LLAMADA DE LA FUNCIÓN CONCATENAR
get_local 0 //Coloca el valor del puntero al inicio de la pilita
2 //Coloca el valor del tamaño de la función al inicio de la pilita.
add //Suma el valor actual del puntero el tamaño de la función.
1 //POR SER EL SEGUNDO OPERADOR SE SUMA UNO MÁS.
add 
set_local 0 //Se cambia el valor del puntero en la stack
call $double_to_int //se hace la llamada a la función para mover puntero IP

//REGRESAR PUNTERO DEL STACK
get_local 0 //Se coloca el puntero al inicio de la pilita
2 //Coloca el valor del tamaño de la función al inicio de la pilita.
diff //Resta el valo actual del puntero el tamaño de la función para retornar el ambito.
1 //POR SER EL SEGUNDO OPERADOR SE RESTA UNO MÁS.
diff 
set_local 0 //Se regresa el valor del puntero en la stack.
//========================FIN CONVERSION==================
 // Traducción del valor que se va a pasar como parametro
set_local $calc //guardo el valor en la posición calculada

//LLAMADA DE LA FUNCIÓN CONCATENAR
get_local 0 //Coloca el valor del puntero al inicio de la pilita
2 //Coloca el valor del tamaño de la función al inicio de la pilita.
add //Suma el valor actual del puntero el tamaño de la función.
set_local 0 //Se cambia el valor del puntero en la stack
call $ConcatenarString //se hace la llamada a la función para mover puntero IP

//REGRESAR PUNTERO DEL STACK
get_local 0 //Se coloca el puntero al inicio de la pilita
2 //Coloca el valor del tamaño de la función al inicio de la pilita.
diff //Resta el valo actual del puntero el tamaño de la función para retornar el ambito.
set_local 0 //Se regresa el valor del puntero en la stack.
// Traducción del valor que se va a pasar como parametro
set_local $calc //guardo el valor en la posición calculada

//LLAMADA DE LA FUNCIÓN CONCATENAR
get_local 0 //Coloca el valor del puntero al inicio de la pilita
2 //Coloca el valor del tamaño de la función al inicio de la pilita.
add //Suma el valor actual del puntero el tamaño de la función.
set_local 0 //Se cambia el valor del puntero en la stack
call $imprimir_cadena //se hace la llamada a la función para mover puntero IP

//REGRESAR PUNTERO DEL STACK
get_local 0 //Se coloca el puntero al inicio de la pilita
2 //Coloca el valor del tamaño de la función al inicio de la pilita.
diff //Resta el valo actual del puntero el tamaño de la función para retornar el ambito.
set_local 0 //Se regresa el valor del puntero en la stack.
//========================FIN IMPRIMIR==================
%c
//Valor a imprimir...
10
Print

//--Función Imprimir

//=============LLAMADA A FUNCIÓN IMPRIMIR===========================

//PARAMETRO1
get_local 0 // me posiciono en el inicio de la función actual.
0// busco la posición del parametro que voy a pasar
add  //Me posicion en el lugar del parametro
2// se coloca el tamaño de la función para poder guardar la variable
add //Se suma el tamaño del ambito para poder pasar el parametro a la posición que lo recibe.
//--------INICIO CONCATENACIÓN----------

//PARAMETRO1
get_local 0 // me posiciono en el inicio de la función actual.
0// busco la posición del parametro que voy a pasar
add  //Me posicion en el lugar del parametro
2// se coloca el tamaño de la función para poder guardar la variable
add //Se suma el tamaño del ambito para poder pasar el parametro a la posición que lo recibe.
//--GUARDAR STRING: Se guarda el puntero del heap el numero de veces del tamaño de la cadena.
get_global 0 //Posicion que quedará hasta el final de la cadena.
get_global 0 
73 //Caracter en ASCII 
tee_global $calc //Se guarda el valor en el stack
1 //Posición del caracter 
add 
110 //Caracter en ASCII 
tee_global $calc //Se guarda el valor en el stack
1 //Posición del caracter 
add 
105 //Caracter en ASCII 
tee_global $calc //Se guarda el valor en el stack
1 //Posición del caracter 
add 
99 //Caracter en ASCII 
tee_global $calc //Se guarda el valor en el stack
1 //Posición del caracter 
add 
105 //Caracter en ASCII 
tee_global $calc //Se guarda el valor en el stack
1 //Posición del caracter 
add 
97 //Caracter en ASCII 
tee_global $calc //Se guarda el valor en el stack
1 //Posición del caracter 
add 
108 //Caracter en ASCII 
tee_global $calc //Se guarda el valor en el stack
1 //Posición del caracter 
add 
58 //Caracter en ASCII 
tee_global $calc //Se guarda el valor en el stack
1 //Posición del caracter 
add 
32 //Caracter en ASCII 
tee_global $calc //Se guarda el valor en el stack
1 //Posición del caracter 
add 
92//Caracter ACII final cadena
tee_global $calc //Se guarda el valor en el stack
1 //Posición del caracter 
add 
set_global 0 //Actualizar valor del puntero 
// Traducción del valor que se va a pasar como parametro
set_local $calc //guardo el valor en la posición calculada

//PARAMETRO2
get_local 0 // me posiciono en el inicio de la función actual.
1 // busco la posición del parametro que voy a pasar
add //Me posicion en el lugar del parametro
2// se coloca el tamaño de la función para poder guardar la variable
add //Se suma el tamaño del ambito para poder pasar el parametro a la posición que lo recibe.
//PASAR CHAR A STRING
 get_global 0
get_global 0
get_local 0 
0  //Posición del objeto en la pila.
add //Posición del inicio del struct en el stack
get_local $calc //Obtener valor del apuntador del heap.
3  //Posición del atributo en el struct
add
get_global $calc //Obtener el valor de la posición del heap.

set_global $calc
get_global 0 
1 
add 
set_global 0
get_global 0
92
set_global $calc
get_global 0 
1 
add 
set_global 0
 // Traducción del valor que se va a pasar como parametro
set_local $calc //guardo el valor en la posición calculada

//LLAMADA DE LA FUNCIÓN CONCATENAR
get_local 0 //Coloca el valor del puntero al inicio de la pilita
2 //Coloca el valor del tamaño de la función al inicio de la pilita.
add //Suma el valor actual del puntero el tamaño de la función.
set_local 0 //Se cambia el valor del puntero en la stack
call $ConcatenarString //se hace la llamada a la función para mover puntero IP

//REGRESAR PUNTERO DEL STACK
get_local 0 //Se coloca el puntero al inicio de la pilita
2 //Coloca el valor del tamaño de la función al inicio de la pilita.
diff //Resta el valo actual del puntero el tamaño de la función para retornar el ambito.
set_local 0 //Se regresa el valor del puntero en la stack.
// Traducción del valor que se va a pasar como parametro
set_local $calc //guardo el valor en la posición calculada

//LLAMADA DE LA FUNCIÓN CONCATENAR
get_local 0 //Coloca el valor del puntero al inicio de la pilita
2 //Coloca el valor del tamaño de la función al inicio de la pilita.
add //Suma el valor actual del puntero el tamaño de la función.
set_local 0 //Se cambia el valor del puntero en la stack
call $imprimir_cadena //se hace la llamada a la función para mover puntero IP

//REGRESAR PUNTERO DEL STACK
get_local 0 //Se coloca el puntero al inicio de la pilita
2 //Coloca el valor del tamaño de la función al inicio de la pilita.
diff //Resta el valo actual del puntero el tamaño de la función para retornar el ambito.
set_local 0 //Se regresa el valor del puntero en la stack.
//========================FIN IMPRIMIR==================
%c
//Valor a imprimir...
10
Print

//--Función Imprimir

//=============LLAMADA A FUNCIÓN IMPRIMIR===========================

//PARAMETRO1
get_local 0 // me posiciono en el inicio de la función actual.
0// busco la posición del parametro que voy a pasar
add  //Me posicion en el lugar del parametro
2// se coloca el tamaño de la función para poder guardar la variable
add //Se suma el tamaño del ambito para poder pasar el parametro a la posición que lo recibe.
//--GUARDAR STRING: Se guarda el puntero del heap el numero de veces del tamaño de la cadena.
get_global 0 //Posicion que quedará hasta el final de la cadena.
get_global 0 
68 //Caracter en ASCII 
tee_global $calc //Se guarda el valor en el stack
1 //Posición del caracter 
add 
80 //Caracter en ASCII 
tee_global $calc //Se guarda el valor en el stack
1 //Posición del caracter 
add 
73 //Caracter en ASCII 
tee_global $calc //Se guarda el valor en el stack
1 //Posición del caracter 
add 
58 //Caracter en ASCII 
tee_global $calc //Se guarda el valor en el stack
1 //Posición del caracter 
add 
32 //Caracter en ASCII 
tee_global $calc //Se guarda el valor en el stack
1 //Posición del caracter 
add 
92//Caracter ACII final cadena
tee_global $calc //Se guarda el valor en el stack
1 //Posición del caracter 
add 
set_global 0 //Actualizar valor del puntero 
// Traducción del valor que se va a pasar como parametro
set_local $calc //guardo el valor en la posición calculada

//LLAMADA DE LA FUNCIÓN CONCATENAR
get_local 0 //Coloca el valor del puntero al inicio de la pilita
2 //Coloca el valor del tamaño de la función al inicio de la pilita.
add //Suma el valor actual del puntero el tamaño de la función.
set_local 0 //Se cambia el valor del puntero en la stack
call $imprimir_cadena //se hace la llamada a la función para mover puntero IP

//REGRESAR PUNTERO DEL STACK
get_local 0 //Se coloca el puntero al inicio de la pilita
2 //Coloca el valor del tamaño de la función al inicio de la pilita.
diff //Resta el valo actual del puntero el tamaño de la función para retornar el ambito.
set_local 0 //Se regresa el valor del puntero en la stack.
//========================FIN IMPRIMIR==================
%c
//Valor a imprimir...
10
Print
//...Inicio declaracion
get_local 0   //posicion actual en el puntero de la pila
1  //posición de la variable en la pila
add   //colocar la posición de la variable en la pilita
0
  //valor inicial de la variable
set_local $calc   //asignación del valor en la pila
//...Fin Declaración
//...........Inicio While
$l34:     //Inicio del ciclo. 
get_local 0
1
add
get_local $calc

13

Lt
    //Codigo de la condición, se asume que el valor de la condición ya está en la pilita.
Eqz   // Se valida que la condición haya sido verdadera.
Br_if $l35   //Si es verdadera, hace un goto a la etiqueta verdadera.
Br $l36  //Si la condición es falsa, hace un goto a la etiqueta falsa.
$l35:  //Inicio de la lista de instrucciones. 

//--Función Imprimir
%d
//Valor a imprimir...
//ASIGNACION DE UN ARREGLO EN UN STRUCT-----------
//POSICION DEL ARREGLO EN STRUCT. ----
//INDICE.
get_local 0
1
add
get_local $calc
//TAMAÑO.
get_local 0 //puntero actual del stck
0//posición del objeto en el stack
add
get_local $calc //Se obtiene la posición del struct en el heap.
4  //Posición del atributo en el struct
add //Se coloca en la pilita la posición del atributo, listo para asingar.
get_global $calc //Tengo el valor donde inicia el arreglo.
0//numero de dimensión
add 
get_global $calc //Obtiene el valor de la posición del heap. 
Lt //Valor_Indice < Tamaño_Dimension
Eqz //Valida si es menor
br_if $l37   //salto etiqueta verdadero
br $error_arreglo  //goto etiqueta falso
$l37:    //inicio etiqueta verdadero
get_local 0 //puntero actual del stck
0//posición del objeto en el stack
add
get_local $calc //Se obtiene la posición del struct en el heap.
4  //Posición del atributo en el struct
add //Se coloca en la pilita la posición del atributo, listo para asingar.
get_global $calc //Tengo el valor donde inicia el arreglo.
1
add 
get_local 0
1
add
get_local $calc

add //Se suma la posicion del arreglo.
get_global $calc
Print
get_local 0 
 1
add 
get_local 0
1
add
get_local $calc

1
add 
set_local $calc
Br $l34  //Al finalizar el ciclo, se hace un goto a la etiqueta de inicio del ciclo.
$l36:  // Inicio de la etiqueta falsa o de salida del ciclo. 
//.......fin while
End
Function $ConcatenarString
get_global 0 //VALOR DONDE INICIA LA CONCATENACIÓN.
get_local 0   //posicion actual en el puntero de la pila
2  //posición de la variable en la pila
add   //colocar la posición de la variable en la pilita
0 //valor inicial del iterador
set_local $calc   //asignación del valor en la pila
$l40:
get_local 0 //Posición del primer parametro
get_local $calc 
get_local 0
2
add
get_local $calc

add //Valor de la posición del caracter actual
get_global $calc //obtengo el valor del caracter
92 //valor del caracter del final de cadena
diff 
eqz  //verifica que los caracteres sean iguales
br_if $l38   //salto etiqueta verdadero
br $l39  //goto etiqueta falso
$l38:    //inicio etiqueta verdadero
get_global 0 //valor actual del apuntador del heap
get_local 0 //Posición del primer parametro en el heap
get_local $calc 
get_local 0
2
add
get_local $calc

add //Valor de la posición del caracter actual
get_global $calc //Obtengo el valor del caracter
set_global $calc //Guardo el valor del caracter en la posicion actual del heap
get_global 0
1 
add 
set_global 0 //Aumente el valor del puntero del heap.
 //----ITERADOR = ITERADOR + 1
get_local 0
2
add
get_local 0
2
add
get_local $calc

1
Add
set_local $calc
br $l40
$l39:
get_local 0   //posicion actual en el puntero de la pila
2  //posición de la variable en la pila
add   //colocar la posición de la variable en la pilita
0 //valor inicial del iterador
set_local $calc   //asignación del valor en la pila
$l41:
get_local 0 //Posición del primer parametro
1 
add 
get_local $calc
get_local 0
2
add
get_local $calc

add //Valor de la posición del caracter actual
get_global $calc //obtengo el valor del caracter
92 //valor del caracter del final de cadena
diff 
eqz  //verifica que los caracteres sean iguales
br_if $l42   //salto etiqueta verdadero
br $l43  //goto etiqueta falso
$l42:    //inicio etiqueta verdadero
get_global 0 //valor actual del apuntador del heap
get_local 0 //Posición del primer parametro
1 
add 
get_local $calc
get_local 0
2
add
get_local $calc

add //Valor de la posición del caracter actual
get_global $calc //Obtengo el valor del caracter
set_global $calc //Guardo el valor del caracter en la posicion actual del heap
get_global 0
1 
add 
set_global 0 //Aumente el valor del puntero del heap.
 //----ITERADOR = ITERADOR + 1
get_local 0
2
add
get_local 0
2
add
get_local $calc

1
Add
set_local $calc
br $l41
$l43:
get_global 0 //valor actual del heap
92 //caracter final de la concatenación
set_global $calc //Se copia el final de cadena
get_global 0 //valor actual del heap 
1 
add 
set_global 0 
End



Function $double_to_int
get_global 0 //POSICION DONDE INICIA EL VALOR EN STRING 

//VALIDAR QUE EL NUMERO A CONVERTIR SEA NEGATIVO.
get_local 0 //Coloca el valor del puntero al inicio de la pilita
get_local $calc
0
Lt //numero<0
eqz 
br_if $l44
br $l45
$l44:
get_local 0 //POSICION PARA ACTUALIZAR VALOR.
get_local 0 //Coloca el valor del puntero al inicio de la pilita
get_local $calc
-1
mult 
set_local $calc
get_global 0
45
set_global $calc
get_global 0
1 
add 
set_global 0
$l45:
//========================INICIO LLAMADA A INT_TO_STRING==================

//PARAMETRO1
get_local 0 // me posiciono en el inicio de la función actual.
0// busco la posición del parametro que voy a pasar
add  //Me posicion en el lugar del parametro
1// se coloca el tamaño de la función para poder guardar la variable
add //Se suma el tamaño del ambito para poder pasar el parametro a la posición que lo recibe.
get_local 0
get_local $calc
// Traducción del valor que se va a pasar como parametro
get_local 0
get_local $calc
// VALOR DEL PARAMETRO
1 
mod
diff //RESTA: VALOR-(VALOR%1) = PARTE ENTERA.
set_local $calc //guardo el valor en la posición calculada

//LLAMADA DE LA FUNCIÓN INT_TOSTRING
get_local 0 //Coloca el valor del puntero al inicio de la pilita
1 //Coloca el valor del tamaño de la función al inicio de la pilita.
add //Suma el valor actual del puntero el tamaño de la función.
set_local 0 //Se cambia el valor del puntero en la stack
call $int_to_string //se hace la llamada a la función para mover puntero IP

//REGRESAR PUNTERO DEL STACK
get_local 0 //Se coloca el puntero al inicio de la pilita
1 //Coloca el valor del tamaño de la función al inicio de la pilita.
diff //Resta el valo actual del puntero el tamaño de la función para retornar el ambito.
set_local 0 //Se regresa el valor del puntero en la stack.
//========================FIN CONVERSION ENTERA.==================
get_local 0 
get_local $calc //VALOR DEL PARAMETRO
1 
mod
br_if $l46
br $l47
$l47:

 //SE CONCATENA EL PUNTO PARA SEPARAR ENTERO DE DECIMAL
get_global 0
46 //ASCII DEL PUNTO
set_global $calc
get_global 0 //valor actual del heap 
1 
add 
set_global 0 
//========================OBTENER LA PARTE DECIMAL DEL NUMERO.==================
get_local 0 
get_local 0 
get_local $calc //VALOR DEL PARAMETRO
1 
mod
100
mult //multiplico el decimal * 100 y lo convierto a cadena.
set_local $calc //Actualizo el valor del parametro.
//========================INICIO LLAMADA A INT_TO_STRING==================

//PARAMETRO1
get_local 0 // me posiciono en el inicio de la función actual.
0// busco la posición del parametro que voy a pasar
add  //Me posicion en el lugar del parametro
1// se coloca el tamaño de la función para poder guardar la variable
add //Se suma el tamaño del ambito para poder pasar el parametro a la posición que lo recibe.
get_local 0
get_local $calc
// Traducción del valor que se va a pasar como parametro
set_local $calc //guardo el valor en la posición calculada

//LLAMADA DE LA FUNCIÓN INT_TOSTRING
get_local 0 //Coloca el valor del puntero al inicio de la pilita
1 //Coloca el valor del tamaño de la función al inicio de la pilita.
add //Suma el valor actual del puntero el tamaño de la función.
set_local 0 //Se cambia el valor del puntero en la stack
call $int_to_string //se hace la llamada a la función para mover puntero IP

//REGRESAR PUNTERO DEL STACK
get_local 0 //Se coloca el puntero al inicio de la pilita
1 //Coloca el valor del tamaño de la función al inicio de la pilita.
diff //Resta el valo actual del puntero el tamaño de la función para retornar el ambito.
set_local 0 //Se regresa el valor del puntero en la stack.
//========================FIN CONVERSION DECIMAL.==================
$l46:
get_global 0 //valor actual del heap
92 //caracter final de la concatenación
set_global $calc //Se copia el final de cadena
get_global 0 //valor actual del heap 
1 
add 
set_global 0 
End



Function $int_to_string
//VALOR DE Y
get_local 0   //posicion actual en el puntero de la pila
1  //posición de la variable en la pila
add   //colocar la posición de la variable en la pilita
0 //valor inicial del iterador
set_local $calc   //asignación del valor en la pila
//VALOR DE r
get_local 0   //posicion actual en el puntero de la pila
2  //posición de la variable en la pila
add   //colocar la posición de la variable en la pilita
get_local 0  //puntero de la pila donde inicia la función
get_local $calc //Valor del parametro.
set_local $calc   //asignación del valor en la pila

//---------------INICIO DE CICLO-----------------
//-----VALIDAR SI EL VALOR ES > 9
get_local 0
2
add
get_local $calc

10
Lt
eqz 
br_if $l51
br $l52
$l52:
$l48:
get_local 0
2
add
get_local $calc
//Valor del numero de repeticiones: r
1 //cuando sea igual a cero se termina
Gte 
eqz  //verifica que sea mayor que 1
br_if $l49   //salto etiqueta verdadero
br $l50  //goto etiqueta falso
$l49:    //inicio etiqueta verdadero
//=============|r=
get_local 0 
2 //Pos de r
add //Obtengo la posición de r para asignar nuevo valor.
//==============|r / 10
get_local 0
2
add
get_local $calc
10
div 
set_local $calc //R = R/10
$l51:
//----Y = Y + 1
get_local 0
1
add
get_local 0
1
add
get_local $calc

1
Add
set_local $calc //Y = Y+1
br $l48
$l50:
get_local 0   //posicion actual en el puntero de la pila
3  //posición de la variable en la pila
add   //colocar la posición de la variable en la pilita
//========================INICIO POTENCIA==================

//PARAMETRO1
get_local 0 // me posiciono en el inicio de la función actual.
0// busco la posición del parametro que voy a pasar
add  //Me posicion en el lugar del parametro
3// se coloca el tamaño de la función para poder guardar la variable
add //Se suma el tamaño del ambito para poder pasar el parametro a la posición que lo recibe.
get_local 0
1
add
get_local $calc
// Traducción del valor que se va a pasar como parametro
1
diff
set_local $calc //guardo el valor en la posición calculada

//LLAMADA DE LA FUNCIÓN CONCATENAR
get_local 0 //Coloca el valor del puntero al inicio de la pilita
3 //Coloca el valor del tamaño de la función al inicio de la pilita.
add //Suma el valor actual del puntero el tamaño de la función.
set_local 0 //Se cambia el valor del puntero en la stack
call $Potencia //se hace la llamada a la función para mover puntero IP

//REGRESAR PUNTERO DEL STACK
get_local 0 //Se coloca el puntero al inicio de la pilita
3 //Coloca el valor del tamaño de la función al inicio de la pilita.
diff //Resta el valo actual del puntero el tamaño de la función para retornar el ambito.
set_local 0 //Se regresa el valor del puntero en la stack.
//========================FIN POTENCIA==================
set_local $calc   //asignación del valor DE LA PONTENCIA

//---------------INICIO DE CICLO-----------------
$l53:
get_local 0
1
add
get_local $calc
//Valor del numero de repeticiones: r
0 //cuando sea igual a cero se termina
Gt 
eqz  //verifica que sea mayor que 1
br_if $l54   //salto etiqueta verdadero
br $l55  //goto etiqueta falso
$l54:    //inicio etiqueta verdadero
//NUMERO_ENTRADA / POTENCIA
get_global 0 //obtengo el puntero del heap.
 get_local 0 
get_local $calc //obtengo el valor del parametro que es el digito a convertir.
get_local 0
3
add
get_local $calc
//TENGO EL VALOR DE LA POTENCIA
div 
//TENGO EL VALOR EN NUMERO ENTERO.
48
add //LO CONVERTÍ EN ASCII.
set_global $calc //COLOCO EL ASCII EN EL HEAP.
get_global 0 //valor actual del heap PARA AUMENTAR.
1 
add 
set_global 0 

//===============valor = valor % inicial;=============
get_local 0 //posicion actual del parametro
get_local 0 //valor actual del parametro
get_local $calc //valor
get_local 0
3
add
get_local $calc

mod
set_local $calc //actualizo el valor del parametro.

//===============inicial = inicial / 10;==============
get_local 0
3//POSICION DE LA POTENCIA.
add
get_local 0
3
add
get_local $calc

10
div //Potencia / 10
set_local $calc //Actualizo el valor de la potencia.

//===============num--;==============
get_local 0
1//NUMERO DE DIGITOS.
add
get_local 0
1
add
get_local $calc

1
diff
set_local $calc
br $l53
$l55:
End



Function $Potencia

//.....INICIO POTENCIA.....

//----DECLARACION DE LA VARAIBLE QUE LLEVARÁ EL ITERADOR: i
get_local 0   //posicion actual en el puntero de la pila
1  //posición de la variable en la pila
add   //colocar la posición de la variable en la pilita
0 //valor inicial del iterador
set_local $calc   //asignación del valor en la pila
//----DECLARACION DE LA VARAIBLE QUE LLEVARÁ EL RESULTADO: resultado
get_local 0   //posicion actual en el puntero de la pila
2  //posición de la variable en la pila
add   //colocar la posición de la variable en la pilita
1 //valor inicial del resultado
set_local $calc   //asignación del valor en la pila
$l56:     //Inicio del ciclo. 
//----CONDICIÓN DEL CICLO i < base: i
get_local 0
1
add
get_local $calc

get_local 0 //Posición del primer parametro
get_local $calc

Lt
Eqz   // Se valida que la condición haya sido verdadera.
Br_if $l57   //Si es verdadera, hace un goto a la etiqueta verdadera.
Br $l58  //Si la condición es falsa, hace un goto a la etiqueta falsa.
$l57:  //Inicio de la lista de instrucciones. 
//----RESULTADO = RESULTADO * BASE
get_local 0
2
add
get_local 0
2
add
get_local $calc

10
Mult
set_local $calc
//----ITERADOR = ITERADOR + 1
get_local 0
1
add
get_local 0
1
add
get_local $calc

1
Add
set_local $calc
Br $l56  //Al finalizar el ciclo, se hace un goto a la etiqueta de inicio del ciclo.
$l58:  // Inicio de la etiqueta falsa o de salida del ciclo. 
//COLOCAR VALOR DEL RESULTADO EN LA CIMA.....
get_local 0
2
add
get_local $calc



//.....FIN POTENCIA.....
End
Function $imprimir_cadena
get_local 0   //posicion actual en el puntero de la pila
1  //posición de la variable en la pila
add   //colocar la posición de la variable en la pilita
0 //valor inicial del iterador
set_local $calc   //asignación del valor en la pila
$l61:
get_local 0 //Posición del primer parametro
get_local $calc 
get_local 0
1
add
get_local $calc

add //Valor de la posición del caracter actual
get_global $calc //obtengo el valor del caracter
92 //valor del caracter del final de cadena
diff 
eqz  //verifica que los caracteres sean iguales
br_if $l59   //salto etiqueta verdadero
br $l60  //goto etiqueta falso
$l59:    //inicio etiqueta verdadero
%c
get_local 0 //Posición del primer parametro
get_local $calc 
get_local 0
1
add
get_local $calc

add //Valor de la posición del caracter actual
get_global $calc //obtengo el valor del caracter
Print
//----ITERADOR = ITERADOR + 1
get_local 0
1
add
get_local 0
1
add
get_local $calc

1
Add
set_local $calc
br $l61
$l60:
End
Function $CompararString
get_local 0   //posicion actual en el puntero de la pila
2  //posición de la variable en la pila
add   //colocar la posición de la variable en la pilita
0 //valor inicial del iterador
set_local $calc   //asignación del valor en la pila
$l64:
get_local 0 //Posición del primer parametro
get_local $calc 
get_local 0
2
add
get_local $calc

add //Valor de la posición del caracter actual
get_global $calc //obtengo el valor del caracter
get_local 0 //Posición del primer parametro
1
add
get_local $calc 
get_local 0
2
add
get_local $calc

add //Valor de la posición del caracter actual
get_global $calc //obtengo el valor del caracter
diff 
eqz  //verifica que los caracteres sean iguales
eqz  //verifica que los caracteres sean iguales
br_if $l62   //salto etiqueta verdadero
br $l63  //goto etiqueta falso
$l62:    //inicio etiqueta verdadero
get_local 0 //Posición del primer parametro
get_local $calc 
get_local 0
2
add
get_local $calc

add //Valor de la posición del caracter actual
get_global $calc //obtengo el valor del caracter
92 //valor del caracter del final de cadena
diff 
eqz  //verifica que los caracteres sean iguales
br_if $l65   //salto etiqueta verdadero
br $l66  //goto etiqueta falso
$l65:    //inicio etiqueta verdadero
//----ITERADOR = ITERADOR + 1
get_local 0
2
add
get_local 0
2
add
get_local $calc

1
Add
set_local $calc
br $l64
$l66:
1 //AL SER IGUALES RETORNO UN UNO EN LA PILITA
br $l67
$l63:
0 //AL SER DIFERENTES RETORNO UN CERO EN LA PILITA
$l67:
End
Function $CalcularPesoString
get_local 0   //posicion actual en el puntero de la pila
2  //posición de la variable en la pila
add   //colocar la posición de la variable en la pilita
0 //valor inicial del iterador
set_local $calc   //asignación del valor en la pila
0 //VALOR DE INICIO DE LA SUMA.
$l70:
get_local 0 //Posición del primer parametro
get_local $calc 
get_local 0
2
add
get_local $calc

add //Valor de la posición del caracter actual
get_global $calc //obtengo el valor del caracter
92 //valor del caracter del final de cadena
diff 
eqz  //verifica que los caracteres sean iguales
br_if $l68   //salto etiqueta verdadero
br $l69  //goto etiqueta falso
$l68:    //inicio etiqueta verdadero
get_local 0 //Posición del primer parametro en el heap
get_local $calc 
get_local 0
2
add
get_local $calc

add //Valor de la posición del caracter actual
get_global $calc //Obtengo el valor del caracter
add //VOY SUMANDO EL VALOR DE LOS CARACTERES.
//----ITERADOR = ITERADOR + 1
get_local 0
2
add
get_local 0
2
add
get_local $calc

1
Add
set_local $calc
br $l70
$l69:
End
